/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v10.6.6324.28497 (NJsonSchema v8.33.6323.36213) (http://NSwag.org)
// </auto-generated>
//----------------------

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';

export interface IArticlesApiClient {
    getArticle(id: number): Promise<ArticleModel | null>;
    deleteArticle(id: number): Promise<Blob | null>;
    updateArticleOrder(model: UpdateArticleOrderModel): Promise<Blob | null>;
    deleteCategory(id: number): Promise<Blob | null>;
    getSection(sectionUrl: string): Promise<SectionModel | null>;
    getSections(): Promise<SectionModel[] | null>;
    getFeaturedArticle(categoryId: number): Promise<ArticleModel | null>;
    getArticleByUrl(categoryId: number, articleUrl: string): Promise<ArticleModel | null>;
    getArticles(categoryId: number): Promise<ArticleHeader[] | null>;
    setFeaturedArticle(id: number): Promise<Blob | null>;
    getCategories(sectionId: number): Promise<CategoryModel[] | null>;
    getCategory(categoryUrl: string): Promise<CategoryModel | null>;
    saveArticle(model: ArticleModel): Promise<ArticleModel | null>;
    saveCategory(model: CategoryModel): Promise<CategoryModel | null>;
}

@inject(String, HttpClient)
export class ArticlesApiClient implements IArticlesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getArticle(id: number): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticle(_response);
        });
    }

    protected processGetArticle(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    deleteArticle(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteArticle(_response);
        });
    }

    protected processDeleteArticle(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    updateArticleOrder(model: UpdateArticleOrderModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article//order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateArticleOrder(_response);
        });
    }

    protected processUpdateArticleOrder(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    deleteCategory(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getSection(sectionUrl: string): Promise<SectionModel | null> {
        let url_ = this.baseUrl + "/api/article/section/{sectionUrl}";
        if (sectionUrl === undefined || sectionUrl === null)
            throw new Error("The parameter 'sectionUrl' must be defined.");
        url_ = url_.replace("{sectionUrl}", encodeURIComponent("" + sectionUrl)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSection(_response);
        });
    }

    protected processGetSection(response: Response): Promise<SectionModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: SectionModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? SectionModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<SectionModel | null>(<any>null);
    }

    getSections(): Promise<SectionModel[] | null> {
        let url_ = this.baseUrl + "/api/article/sections";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSections(_response);
        });
    }

    protected processGetSections(response: Response): Promise<SectionModel[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: SectionModel[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SectionModel.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<SectionModel[] | null>(<any>null);
    }

    getFeaturedArticle(categoryId: number): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article/{categoryId}/featured";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFeaturedArticle(_response);
        });
    }

    protected processGetFeaturedArticle(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    getArticleByUrl(categoryId: number, articleUrl: string): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article/url/{categoryId}/{articleUrl}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        if (articleUrl === undefined || articleUrl === null)
            throw new Error("The parameter 'articleUrl' must be defined.");
        url_ = url_.replace("{articleUrl}", encodeURIComponent("" + articleUrl)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticleByUrl(_response);
        });
    }

    protected processGetArticleByUrl(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    getArticles(categoryId: number): Promise<ArticleHeader[] | null> {
        let url_ = this.baseUrl + "/api/article/{categoryId}/all";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticles(_response);
        });
    }

    protected processGetArticles(response: Response): Promise<ArticleHeader[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleHeader[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ArticleHeader.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleHeader[] | null>(<any>null);
    }

    setFeaturedArticle(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article/{id}/featured";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetFeaturedArticle(_response);
        });
    }

    protected processSetFeaturedArticle(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getCategories(sectionId: number): Promise<CategoryModel[] | null> {
        let url_ = this.baseUrl + "/api/article/categories/{sectionId}";
        if (sectionId === undefined || sectionId === null)
            throw new Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<CategoryModel[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CategoryModel[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CategoryModel.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CategoryModel[] | null>(<any>null);
    }

    getCategory(categoryUrl: string): Promise<CategoryModel | null> {
        let url_ = this.baseUrl + "/api/article/category/{categoryUrl}";
        if (categoryUrl === undefined || categoryUrl === null)
            throw new Error("The parameter 'categoryUrl' must be defined.");
        url_ = url_.replace("{categoryUrl}", encodeURIComponent("" + categoryUrl)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<CategoryModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CategoryModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CategoryModel | null>(<any>null);
    }

    saveArticle(model: ArticleModel): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveArticle(_response);
        });
    }

    protected processSaveArticle(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    saveCategory(model: CategoryModel): Promise<CategoryModel | null> {
        let url_ = this.baseUrl + "/api/article/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveCategory(_response);
        });
    }

    protected processSaveCategory(response: Response): Promise<CategoryModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CategoryModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CategoryModel | null>(<any>null);
    }
}

export interface IBlobApiClient {
    test(): Promise<string | null>;
    uploadSingle(file: FileDetails): Promise<string | null>;
}

@inject(String, HttpClient)
export class BlobApiClient implements IBlobApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    test(): Promise<string | null> {
        let url_ = this.baseUrl + "/api/blob/monitor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: Response): Promise<string | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: string | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    uploadSingle(file: FileDetails): Promise<string | null> {
        let url_ = this.baseUrl + "/api/blob/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file ? file.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadSingle(_response);
        });
    }

    protected processUploadSingle(response: Response): Promise<string | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: string | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }
}

export interface ICompaniesApiClient {
    getCompany(ticker: string): Promise<Company | null>;
    search(request: CompanySearchRequest): Promise<CompanyDetails[] | null>;
}

@inject(String, HttpClient)
export class CompaniesApiClient implements ICompaniesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getCompany(ticker: string): Promise<Company | null> {
        let url_ = this.baseUrl + "/api/company/{ticker}";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompany(_response);
        });
    }

    protected processGetCompany(response: Response): Promise<Company | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Company | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Company.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Company | null>(<any>null);
    }

    search(request: CompanySearchRequest): Promise<CompanyDetails[] | null> {
        let url_ = this.baseUrl + "/api/company/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request ? request.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<CompanyDetails[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyDetails[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CompanyDetails.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyDetails[] | null>(<any>null);
    }
}

export interface IIndicatorsApiClient {
    getIndicator(id: number): Promise<Indicator | null>;
    deleteIndicator(id: number): Promise<Blob | null>;
    getIndicatorsAll(period: number): Promise<Indicator[] | null>;
    getIndicators(): Promise<IndicatorCore[] | null>;
    saveIndicator(model: Indicator): Promise<Indicator | null>;
}

@inject(String, HttpClient)
export class IndicatorsApiClient implements IIndicatorsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getIndicator(id: number): Promise<Indicator | null> {
        let url_ = this.baseUrl + "/api/indicator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndicator(_response);
        });
    }

    protected processGetIndicator(response: Response): Promise<Indicator | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Indicator | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Indicator.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Indicator | null>(<any>null);
    }

    deleteIndicator(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/indicator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIndicator(_response);
        });
    }

    protected processDeleteIndicator(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getIndicatorsAll(period: number): Promise<Indicator[] | null> {
        let url_ = this.baseUrl + "/api/indicator/{period}/all";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndicatorsAll(_response);
        });
    }

    protected processGetIndicatorsAll(response: Response): Promise<Indicator[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Indicator[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Indicator.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Indicator[] | null>(<any>null);
    }

    getIndicators(): Promise<IndicatorCore[] | null> {
        let url_ = this.baseUrl + "/api/indicator/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndicators(_response);
        });
    }

    protected processGetIndicators(response: Response): Promise<IndicatorCore[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: IndicatorCore[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(IndicatorCore.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<IndicatorCore[] | null>(<any>null);
    }

    saveIndicator(model: Indicator): Promise<Indicator | null> {
        let url_ = this.baseUrl + "/api/indicator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveIndicator(_response);
        });
    }

    protected processSaveIndicator(response: Response): Promise<Indicator | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Indicator | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Indicator.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Indicator | null>(<any>null);
    }
}

export interface IJobsApiClient {
    cancelScheduledJob(jobId: number): Promise<Blob | null>;
    pauseScheduledJob(jobId: number): Promise<Blob | null>;
    resumeScheduledJob(jobId: number): Promise<Blob | null>;
    clearJobsHistory(jobType: number): Promise<Blob | null>;
    deleteScheduledJob(jobId: number): Promise<Blob | null>;
    startScheduledJobs(jobType: number): Promise<ScheduledJob | null>;
    getSheduledJobHistory(jobType: number): Promise<ScheduledJob[] | null>;
    getCurrentJob(jobType: number): Promise<ScheduledJob | null>;
    getJob(jobId: number): Promise<ScheduledJob | null>;
}

@inject(String, HttpClient)
export class JobsApiClient implements IJobsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    cancelScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/cancel/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelScheduledJob(_response);
        });
    }

    protected processCancelScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    pauseScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/pause/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPauseScheduledJob(_response);
        });
    }

    protected processPauseScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    resumeScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/resume/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumeScheduledJob(_response);
        });
    }

    protected processResumeScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    clearJobsHistory(jobType: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/history/clear/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearJobsHistory(_response);
        });
    }

    protected processClearJobsHistory(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    deleteScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/delete/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteScheduledJob(_response);
        });
    }

    protected processDeleteScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    startScheduledJobs(jobType: number): Promise<ScheduledJob | null> {
        let url_ = this.baseUrl + "/api/job/start/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartScheduledJobs(_response);
        });
    }

    protected processStartScheduledJobs(response: Response): Promise<ScheduledJob | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduledJob.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob | null>(<any>null);
    }

    getSheduledJobHistory(jobType: number): Promise<ScheduledJob[] | null> {
        let url_ = this.baseUrl + "/api/job/history/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSheduledJobHistory(_response);
        });
    }

    protected processGetSheduledJobHistory(response: Response): Promise<ScheduledJob[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ScheduledJob.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob[] | null>(<any>null);
    }

    getCurrentJob(jobType: number): Promise<ScheduledJob | null> {
        let url_ = this.baseUrl + "/api/job/current/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentJob(_response);
        });
    }

    protected processGetCurrentJob(response: Response): Promise<ScheduledJob | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduledJob.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob | null>(<any>null);
    }

    getJob(jobId: number): Promise<ScheduledJob | null> {
        let url_ = this.baseUrl + "/api/job/info/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<ScheduledJob | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduledJob.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob | null>(<any>null);
    }
}

export interface ILayoutApiClient {
    getLayoutsForPeriod(period: number): Promise<ChartLayoutModel[] | null>;
    getLayout(layoutId: number): Promise<ChartLayoutModel | null>;
    getDefaultLayout(period: number): Promise<ChartLayoutModel | null>;
    saveLayout(model: ChartLayoutModel): Promise<ChartLayoutModel | null>;
}

@inject(String, HttpClient)
export class LayoutApiClient implements ILayoutApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getLayoutsForPeriod(period: number): Promise<ChartLayoutModel[] | null> {
        let url_ = this.baseUrl + "/api/layout/period/{period}";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLayoutsForPeriod(_response);
        });
    }

    protected processGetLayoutsForPeriod(response: Response): Promise<ChartLayoutModel[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChartLayoutModel.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel[] | null>(<any>null);
    }

    getLayout(layoutId: number): Promise<ChartLayoutModel | null> {
        let url_ = this.baseUrl + "/api/layout/{layoutId}";
        if (layoutId === undefined || layoutId === null)
            throw new Error("The parameter 'layoutId' must be defined.");
        url_ = url_.replace("{layoutId}", encodeURIComponent("" + layoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLayout(_response);
        });
    }

    protected processGetLayout(response: Response): Promise<ChartLayoutModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChartLayoutModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel | null>(<any>null);
    }

    getDefaultLayout(period: number): Promise<ChartLayoutModel | null> {
        let url_ = this.baseUrl + "/api/layout/period/{period}/default";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefaultLayout(_response);
        });
    }

    protected processGetDefaultLayout(response: Response): Promise<ChartLayoutModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChartLayoutModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel | null>(<any>null);
    }

    saveLayout(model: ChartLayoutModel): Promise<ChartLayoutModel | null> {
        let url_ = this.baseUrl + "/api/layout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveLayout(_response);
        });
    }

    protected processSaveLayout(response: Response): Promise<ChartLayoutModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChartLayoutModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel | null>(<any>null);
    }
}

export interface ILogsApiClient {
    getJobLogs(jobId: number): Promise<ProcessorLog[] | null>;
    deleteJobLogs(jobId: number): Promise<Blob | null>;
    deleteAllLogs(jobType: number): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class LogsApiClient implements ILogsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getJobLogs(jobId: number): Promise<ProcessorLog[] | null> {
        let url_ = this.baseUrl + "/api/logs/job/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJobLogs(_response);
        });
    }

    protected processGetJobLogs(response: Response): Promise<ProcessorLog[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ProcessorLog[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProcessorLog.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ProcessorLog[] | null>(<any>null);
    }

    deleteJobLogs(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/logs/job/delete/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteJobLogs(_response);
        });
    }

    protected processDeleteJobLogs(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    deleteAllLogs(jobType: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/logs/job-type/delete/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAllLogs(_response);
        });
    }

    protected processDeleteAllLogs(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export interface IRulesApiClient {
    getRule(id: number): Promise<Rule | null>;
    deleteRule(id: number): Promise<Blob | null>;
    getRules(period: number): Promise<Rule[] | null>;
    saveRule(model: Rule): Promise<Rule | null>;
}

@inject(String, HttpClient)
export class RulesApiClient implements IRulesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getRule(id: number): Promise<Rule | null> {
        let url_ = this.baseUrl + "/api/rule/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRule(_response);
        });
    }

    protected processGetRule(response: Response): Promise<Rule | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Rule | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Rule.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Rule | null>(<any>null);
    }

    deleteRule(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/rule/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRule(_response);
        });
    }

    protected processDeleteRule(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getRules(period: number): Promise<Rule[] | null> {
        let url_ = this.baseUrl + "/api/rule/{period}/all";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRules(_response);
        });
    }

    protected processGetRules(response: Response): Promise<Rule[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Rule[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Rule.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Rule[] | null>(<any>null);
    }

    saveRule(model: Rule): Promise<Rule | null> {
        let url_ = this.baseUrl + "/api/rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveRule(_response);
        });
    }

    protected processSaveRule(response: Response): Promise<Rule | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Rule | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Rule.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Rule | null>(<any>null);
    }
}

export interface IRuleSetsApiClient {
    getRuleSet(id: number): Promise<RuleSetModel | null>;
    deleteRuleSet(id: number): Promise<Blob | null>;
    getRuleSets(period: number): Promise<RuleSetModel[] | null>;
    saveRuleSet(model: RuleSetModel): Promise<RuleSetModel | null>;
    getStrategyRuleSets(id: number): Promise<VStrategyRuleSet[] | null>;
    saveStrategyRuleSets(id: number, ruleSets: VStrategyRuleSet[]): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class RuleSetsApiClient implements IRuleSetsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getRuleSet(id: number): Promise<RuleSetModel | null> {
        let url_ = this.baseUrl + "/api/ruleset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRuleSet(_response);
        });
    }

    protected processGetRuleSet(response: Response): Promise<RuleSetModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: RuleSetModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? RuleSetModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<RuleSetModel | null>(<any>null);
    }

    deleteRuleSet(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/ruleset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRuleSet(_response);
        });
    }

    protected processDeleteRuleSet(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getRuleSets(period: number): Promise<RuleSetModel[] | null> {
        let url_ = this.baseUrl + "/api/ruleset/{period}/all";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRuleSets(_response);
        });
    }

    protected processGetRuleSets(response: Response): Promise<RuleSetModel[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: RuleSetModel[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RuleSetModel.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<RuleSetModel[] | null>(<any>null);
    }

    saveRuleSet(model: RuleSetModel): Promise<RuleSetModel | null> {
        let url_ = this.baseUrl + "/api/ruleset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveRuleSet(_response);
        });
    }

    protected processSaveRuleSet(response: Response): Promise<RuleSetModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: RuleSetModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? RuleSetModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<RuleSetModel | null>(<any>null);
    }

    getStrategyRuleSets(id: number): Promise<VStrategyRuleSet[] | null> {
        let url_ = this.baseUrl + "/api/ruleset/strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategyRuleSets(_response);
        });
    }

    protected processGetStrategyRuleSets(response: Response): Promise<VStrategyRuleSet[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: VStrategyRuleSet[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(VStrategyRuleSet.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<VStrategyRuleSet[] | null>(<any>null);
    }

    saveStrategyRuleSets(id: number, ruleSets: VStrategyRuleSet[]): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/ruleset/strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let contentData_: any = [];
        if (ruleSets) {
            for (let item of ruleSets)
                contentData_.push(item.toJSON());
        }
        const content_ = JSON.stringify(ruleSets ? contentData_ : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveStrategyRuleSets(_response);
        });
    }

    protected processSaveStrategyRuleSets(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export interface IStockApiClient {
    updateQuotes(ticker: string): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class StockApiClient implements IStockApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    updateQuotes(ticker: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/stock/{ticker}/update-quotes";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateQuotes(_response);
        });
    }

    protected processUpdateQuotes(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export interface IPlaygroundApiClient {
    loadPlayground(ticker: string, strategyId: number, bars: number, date: number): Promise<CompanyChartData | null>;
    next(ticker: string, strategyId: number): Promise<CompanyChartData | null>;
    prev(ticker: string, strategyId: number): Promise<CompanyChartData | null>;
}

@inject(String, HttpClient)
export class PlaygroundApiClient implements IPlaygroundApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    loadPlayground(ticker: string, strategyId: number, bars: number, date: number): Promise<CompanyChartData | null> {
        let url_ = this.baseUrl + "/api/playground/{ticker}/{strategyId}/{bars}/{date}";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId)); 
        if (bars === undefined || bars === null)
            throw new Error("The parameter 'bars' must be defined.");
        url_ = url_.replace("{bars}", encodeURIComponent("" + bars)); 
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoadPlayground(_response);
        });
    }

    protected processLoadPlayground(response: Response): Promise<CompanyChartData | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyChartData | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyChartData.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyChartData | null>(<any>null);
    }

    next(ticker: string, strategyId: number): Promise<CompanyChartData | null> {
        let url_ = this.baseUrl + "/api/playground/{ticker}/{strategyId}/next";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNext(_response);
        });
    }

    protected processNext(response: Response): Promise<CompanyChartData | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyChartData | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyChartData.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyChartData | null>(<any>null);
    }

    prev(ticker: string, strategyId: number): Promise<CompanyChartData | null> {
        let url_ = this.baseUrl + "/api/playground/{ticker}/{strategyId}/prev";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrev(_response);
        });
    }

    protected processPrev(response: Response): Promise<CompanyChartData | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyChartData | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyChartData.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyChartData | null>(<any>null);
    }
}

export interface IStrategiesApiClient {
    geStrategySummaries(): Promise<StrategySummary[] | null>;
    getStrategyByUrl(url: string): Promise<StrategyModel | null>;
    getStrategySummaryByUrl(url: string): Promise<StrategySummary | null>;
    getStrategyById(id: number): Promise<Strategy | null>;
    saveStrategy(model: StrategyModel): Promise<StrategyModel | null>;
    deleteStrategy(id: number): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class StrategiesApiClient implements IStrategiesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    geStrategySummaries(): Promise<StrategySummary[] | null> {
        let url_ = this.baseUrl + "/api/strategy/getSummaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeStrategySummaries(_response);
        });
    }

    protected processGeStrategySummaries(response: Response): Promise<StrategySummary[] | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategySummary[] | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StrategySummary.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategySummary[] | null>(<any>null);
    }

    getStrategyByUrl(url: string): Promise<StrategyModel | null> {
        let url_ = this.baseUrl + "/api/strategy/getByUrl/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategyByUrl(_response);
        });
    }

    protected processGetStrategyByUrl(response: Response): Promise<StrategyModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategyModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? StrategyModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategyModel | null>(<any>null);
    }

    getStrategySummaryByUrl(url: string): Promise<StrategySummary | null> {
        let url_ = this.baseUrl + "/api/strategy/getSummaryByUrl/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategySummaryByUrl(_response);
        });
    }

    protected processGetStrategySummaryByUrl(response: Response): Promise<StrategySummary | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategySummary | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? StrategySummary.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategySummary | null>(<any>null);
    }

    getStrategyById(id: number): Promise<Strategy | null> {
        let url_ = this.baseUrl + "/api/strategy/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategyById(_response);
        });
    }

    protected processGetStrategyById(response: Response): Promise<Strategy | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Strategy | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Strategy.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Strategy | null>(<any>null);
    }

    saveStrategy(model: StrategyModel): Promise<StrategyModel | null> {
        let url_ = this.baseUrl + "/api/strategy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveStrategy(_response);
        });
    }

    protected processSaveStrategy(response: Response): Promise<StrategyModel | null> {
        const status = response.status;
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategyModel | null = null;
            let resultData200 = responseText === "" ? null : jsonParse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? StrategyModel.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategyModel | null>(<any>null);
    }

    deleteStrategy(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteStrategy(_response);
        });
    }

    protected processDeleteStrategy(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export class ArticleHeader implements IArticleHeader {
    articleId: number;
    title?: string | undefined;
    url?: string | undefined;
    summary?: string | undefined;
    categoryId: number;
    orderId: number;
    isFeatured: boolean;
    deleted: boolean;

    constructor(data?: IArticleHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.articleId = data["articleId"];
            this.title = data["title"];
            this.url = data["url"];
            this.summary = data["summary"];
            this.categoryId = data["categoryId"];
            this.orderId = data["orderId"];
            this.isFeatured = data["isFeatured"];
            this.deleted = data["deleted"];
        }
    }

    static fromJS(data: any, _mappings?: any): ArticleHeader {
        return createInstance<ArticleHeader>(data, _mappings, ArticleHeader);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articleId"] = this.articleId;
        data["title"] = this.title;
        data["url"] = this.url;
        data["summary"] = this.summary;
        data["categoryId"] = this.categoryId;
        data["orderId"] = this.orderId;
        data["isFeatured"] = this.isFeatured;
        data["deleted"] = this.deleted;
        return data; 
    }
}

export interface IArticleHeader {
    articleId: number;
    title?: string | undefined;
    url?: string | undefined;
    summary?: string | undefined;
    categoryId: number;
    orderId: number;
    isFeatured: boolean;
    deleted: boolean;
}

export class ArticleModel extends ArticleHeader implements IArticleModel {
    articleBlocks?: ArticleBlock[] | undefined;

    constructor(data?: IArticleModel) {
        super(data);
    }

    init(data?: any, _mappings?: any) {
        super.init(data);
        if (data) {
            if (data["articleBlocks"] && data["articleBlocks"].constructor === Array) {
                this.articleBlocks = [];
                for (let item of data["articleBlocks"])
                    this.articleBlocks.push(ArticleBlock.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ArticleModel {
        return createInstance<ArticleModel>(data, _mappings, ArticleModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.articleBlocks && this.articleBlocks.constructor === Array) {
            data["articleBlocks"] = [];
            for (let item of this.articleBlocks)
                data["articleBlocks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IArticleModel extends IArticleHeader {
    articleBlocks?: ArticleBlock[] | undefined;
}

export class ArticleBlock implements IArticleBlock {
    valid: boolean;
    blockType: ArticleBlockType;
    text?: string | undefined;
    headingType?: HeadingType | undefined;
    imageUrl?: string | undefined;
    items?: ArticleBlockItem[] | undefined;

    constructor(data?: IArticleBlock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.valid = data["valid"];
            this.blockType = data["blockType"];
            this.text = data["text"];
            this.headingType = data["headingType"];
            this.imageUrl = data["imageUrl"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ArticleBlockItem.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ArticleBlock {
        return createInstance<ArticleBlock>(data, _mappings, ArticleBlock);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valid"] = this.valid;
        data["blockType"] = this.blockType;
        data["text"] = this.text;
        data["headingType"] = this.headingType;
        data["imageUrl"] = this.imageUrl;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IArticleBlock {
    valid: boolean;
    blockType: ArticleBlockType;
    text?: string | undefined;
    headingType?: HeadingType | undefined;
    imageUrl?: string | undefined;
    items?: ArticleBlockItem[] | undefined;
}

export enum ArticleBlockType {
    Paragraph = <any>"Paragraph", 
    Heading = <any>"Heading", 
    Image = <any>"Image", 
    List = <any>"List", 
    Unset = <any>"Unset", 
}

export enum HeadingType {
    H1 = <any>"H1", 
    H2 = <any>"H2", 
    H3 = <any>"H3", 
    H4 = <any>"H4", 
    H5 = <any>"H5", 
}

export class ArticleBlockItem implements IArticleBlockItem {
    text?: string | undefined;
    valid: boolean;

    constructor(data?: IArticleBlockItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.text = data["text"];
            this.valid = data["valid"];
        }
    }

    static fromJS(data: any, _mappings?: any): ArticleBlockItem {
        return createInstance<ArticleBlockItem>(data, _mappings, ArticleBlockItem);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["valid"] = this.valid;
        return data; 
    }
}

export interface IArticleBlockItem {
    text?: string | undefined;
    valid: boolean;
}

export class UpdateArticleOrderModel implements IUpdateArticleOrderModel {
    articleId: number;
    orderId: number;

    constructor(data?: IUpdateArticleOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.articleId = data["articleId"];
            this.orderId = data["orderId"];
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateArticleOrderModel {
        return createInstance<UpdateArticleOrderModel>(data, _mappings, UpdateArticleOrderModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articleId"] = this.articleId;
        data["orderId"] = this.orderId;
        return data; 
    }
}

export interface IUpdateArticleOrderModel {
    articleId: number;
    orderId: number;
}

export class SectionModel implements ISectionModel {
    sectionId: number;
    title?: string | undefined;
    url?: string | undefined;
    orderId: number;
    isDeleted: boolean;

    constructor(data?: ISectionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.sectionId = data["sectionId"];
            this.title = data["title"];
            this.url = data["url"];
            this.orderId = data["orderId"];
            this.isDeleted = data["isDeleted"];
        }
    }

    static fromJS(data: any, _mappings?: any): SectionModel {
        return createInstance<SectionModel>(data, _mappings, SectionModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId;
        data["title"] = this.title;
        data["url"] = this.url;
        data["orderId"] = this.orderId;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface ISectionModel {
    sectionId: number;
    title?: string | undefined;
    url?: string | undefined;
    orderId: number;
    isDeleted: boolean;
}

export class CategoryModel implements ICategoryModel {
    categoryId: number;
    title?: string | undefined;
    orderId: number;
    url?: string | undefined;
    sectionId: number;
    deleted: boolean;

    constructor(data?: ICategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.categoryId = data["categoryId"];
            this.title = data["title"];
            this.orderId = data["orderId"];
            this.url = data["url"];
            this.sectionId = data["sectionId"];
            this.deleted = data["deleted"];
        }
    }

    static fromJS(data: any, _mappings?: any): CategoryModel {
        return createInstance<CategoryModel>(data, _mappings, CategoryModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["title"] = this.title;
        data["orderId"] = this.orderId;
        data["url"] = this.url;
        data["sectionId"] = this.sectionId;
        data["deleted"] = this.deleted;
        return data; 
    }
}

export interface ICategoryModel {
    categoryId: number;
    title?: string | undefined;
    orderId: number;
    url?: string | undefined;
    sectionId: number;
    deleted: boolean;
}

export class FileDetails implements IFileDetails {
    fileName?: string | undefined;
    fileBody?: string | undefined;
    category: FileCategory;

    constructor(data?: IFileDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileBody = data["fileBody"];
            this.category = data["category"];
        }
    }

    static fromJS(data: any, _mappings?: any): FileDetails {
        return createInstance<FileDetails>(data, _mappings, FileDetails);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileBody"] = this.fileBody;
        data["category"] = this.category;
        return data; 
    }
}

export interface IFileDetails {
    fileName?: string | undefined;
    fileBody?: string | undefined;
    category: FileCategory;
}

export enum FileCategory {
    Articles = <any>"Articles", 
    Journal = <any>"Journal", 
}

export class Company implements ICompany {
    ticker?: string | undefined;
    name?: string | undefined;
    marketCap: number;
    sector?: string | undefined;
    industry?: string | undefined;
    summaryUrl?: string | undefined;
    lastUpdated: Date;
    lastCalculated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    liveQuoteJson?: string | undefined;
    historyQuotesJson?: string | undefined;
    nextReportDate: Date;
    historyQuotes?: QuotesModel[] | undefined;
    updateSuccessful: boolean;
    updateError?: string | undefined;
    calculatedSuccessful: boolean;
    calculatedError?: string | undefined;
    filtered: boolean;
    startDate: Date;
    endDate: Date;
    sectorId: number;
    industryId: number;
    sP500: boolean;
    isIndex: boolean;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.ticker = data["ticker"];
            this.name = data["name"];
            this.marketCap = data["marketCap"];
            this.sector = data["sector"];
            this.industry = data["industry"];
            this.summaryUrl = data["summaryUrl"];
            this.lastUpdated = data["lastUpdated"] ? new Date(data["lastUpdated"].toString()) : <any>undefined;
            this.lastCalculated = data["lastCalculated"] ? new Date(data["lastCalculated"].toString()) : <any>undefined;
            this.volume = data["volume"];
            this.price = data["price"];
            this.highestPrice52 = data["highestPrice52"];
            this.lowestPrice52 = data["lowestPrice52"];
            this.chaosPercentage = data["chaosPercentage"];
            this.liveQuoteJson = data["liveQuoteJson"];
            this.historyQuotesJson = data["historyQuotesJson"];
            this.nextReportDate = data["nextReportDate"] ? new Date(data["nextReportDate"].toString()) : <any>undefined;
            if (data["historyQuotes"] && data["historyQuotes"].constructor === Array) {
                this.historyQuotes = [];
                for (let item of data["historyQuotes"])
                    this.historyQuotes.push(QuotesModel.fromJS(item, _mappings));
            }
            this.updateSuccessful = data["updateSuccessful"];
            this.updateError = data["updateError"];
            this.calculatedSuccessful = data["calculatedSuccessful"];
            this.calculatedError = data["calculatedError"];
            this.filtered = data["filtered"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.sectorId = data["sectorId"];
            this.industryId = data["industryId"];
            this.sP500 = data["sP500"];
            this.isIndex = data["isIndex"];
        }
    }

    static fromJS(data: any, _mappings?: any): Company {
        return createInstance<Company>(data, _mappings, Company);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker;
        data["name"] = this.name;
        data["marketCap"] = this.marketCap;
        data["sector"] = this.sector;
        data["industry"] = this.industry;
        data["summaryUrl"] = this.summaryUrl;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["lastCalculated"] = this.lastCalculated ? this.lastCalculated.toISOString() : <any>undefined;
        data["volume"] = this.volume;
        data["price"] = this.price;
        data["highestPrice52"] = this.highestPrice52;
        data["lowestPrice52"] = this.lowestPrice52;
        data["chaosPercentage"] = this.chaosPercentage;
        data["liveQuoteJson"] = this.liveQuoteJson;
        data["historyQuotesJson"] = this.historyQuotesJson;
        data["nextReportDate"] = this.nextReportDate ? this.nextReportDate.toISOString() : <any>undefined;
        if (this.historyQuotes && this.historyQuotes.constructor === Array) {
            data["historyQuotes"] = [];
            for (let item of this.historyQuotes)
                data["historyQuotes"].push(item.toJSON());
        }
        data["updateSuccessful"] = this.updateSuccessful;
        data["updateError"] = this.updateError;
        data["calculatedSuccessful"] = this.calculatedSuccessful;
        data["calculatedError"] = this.calculatedError;
        data["filtered"] = this.filtered;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["sectorId"] = this.sectorId;
        data["industryId"] = this.industryId;
        data["sP500"] = this.sP500;
        data["isIndex"] = this.isIndex;
        return data; 
    }
}

export interface ICompany {
    ticker?: string | undefined;
    name?: string | undefined;
    marketCap: number;
    sector?: string | undefined;
    industry?: string | undefined;
    summaryUrl?: string | undefined;
    lastUpdated: Date;
    lastCalculated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    liveQuoteJson?: string | undefined;
    historyQuotesJson?: string | undefined;
    nextReportDate: Date;
    historyQuotes?: QuotesModel[] | undefined;
    updateSuccessful: boolean;
    updateError?: string | undefined;
    calculatedSuccessful: boolean;
    calculatedError?: string | undefined;
    filtered: boolean;
    startDate: Date;
    endDate: Date;
    sectorId: number;
    industryId: number;
    sP500: boolean;
    isIndex: boolean;
}

export class QuotesModel implements IQuotesModel {
    date: Date;
    close: number;
    volume: number;
    open: number;
    high: number;
    low: number;
    volumeAsText?: string | undefined;
    impulse: number;

    constructor(data?: IQuotesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.close = data["close"];
            this.volume = data["volume"];
            this.open = data["open"];
            this.high = data["high"];
            this.low = data["low"];
            this.volumeAsText = data["volumeAsText"];
            this.impulse = data["impulse"];
        }
    }

    static fromJS(data: any, _mappings?: any): QuotesModel {
        return createInstance<QuotesModel>(data, _mappings, QuotesModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["close"] = this.close;
        data["volume"] = this.volume;
        data["open"] = this.open;
        data["high"] = this.high;
        data["low"] = this.low;
        data["volumeAsText"] = this.volumeAsText;
        data["impulse"] = this.impulse;
        return data; 
    }
}

export interface IQuotesModel {
    date: Date;
    close: number;
    volume: number;
    open: number;
    high: number;
    low: number;
    volumeAsText?: string | undefined;
    impulse: number;
}

export class CompanySearchRequest implements ICompanySearchRequest {
    ticker?: string | undefined;
    maxCount: number;

    constructor(data?: ICompanySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.ticker = data["ticker"];
            this.maxCount = data["maxCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): CompanySearchRequest {
        return createInstance<CompanySearchRequest>(data, _mappings, CompanySearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker;
        data["maxCount"] = this.maxCount;
        return data; 
    }
}

export interface ICompanySearchRequest {
    ticker?: string | undefined;
    maxCount: number;
}

export class CompanyDetails implements ICompanyDetails {
    ticker?: string | undefined;
    name?: string | undefined;
    sector?: string | undefined;
    industry?: string | undefined;
    summaryUrl?: string | undefined;
    lastUpdated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    updateSuccessful: boolean;
    filtered: boolean;

    constructor(data?: ICompanyDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.ticker = data["ticker"];
            this.name = data["name"];
            this.sector = data["sector"];
            this.industry = data["industry"];
            this.summaryUrl = data["summaryUrl"];
            this.lastUpdated = data["lastUpdated"] ? new Date(data["lastUpdated"].toString()) : <any>undefined;
            this.volume = data["volume"];
            this.price = data["price"];
            this.highestPrice52 = data["highestPrice52"];
            this.lowestPrice52 = data["lowestPrice52"];
            this.chaosPercentage = data["chaosPercentage"];
            this.updateSuccessful = data["updateSuccessful"];
            this.filtered = data["filtered"];
        }
    }

    static fromJS(data: any, _mappings?: any): CompanyDetails {
        return createInstance<CompanyDetails>(data, _mappings, CompanyDetails);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker;
        data["name"] = this.name;
        data["sector"] = this.sector;
        data["industry"] = this.industry;
        data["summaryUrl"] = this.summaryUrl;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["volume"] = this.volume;
        data["price"] = this.price;
        data["highestPrice52"] = this.highestPrice52;
        data["lowestPrice52"] = this.lowestPrice52;
        data["chaosPercentage"] = this.chaosPercentage;
        data["updateSuccessful"] = this.updateSuccessful;
        data["filtered"] = this.filtered;
        return data; 
    }
}

export interface ICompanyDetails {
    ticker?: string | undefined;
    name?: string | undefined;
    sector?: string | undefined;
    industry?: string | undefined;
    summaryUrl?: string | undefined;
    lastUpdated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    updateSuccessful: boolean;
    filtered: boolean;
}

export class Indicator implements IIndicator {
    indicatorId: number;
    name?: string | undefined;
    description?: string | undefined;
    period: QuotePeriod;
    jsonParams?: string | undefined;
    lastUpdated: Date;
    deleted: boolean;
    global: boolean;
    chartPlotNumber: number;
    chartColor?: string | undefined;
    params?: IndicatorParam[] | undefined;
    chartType: ChartType;

    constructor(data?: IIndicator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.indicatorId = data["indicatorId"];
            this.name = data["name"];
            this.description = data["description"];
            this.period = data["period"];
            this.jsonParams = data["jsonParams"];
            this.lastUpdated = data["lastUpdated"] ? new Date(data["lastUpdated"].toString()) : <any>undefined;
            this.deleted = data["deleted"];
            this.global = data["global"];
            this.chartPlotNumber = data["chartPlotNumber"];
            this.chartColor = data["chartColor"];
            if (data["params"] && data["params"].constructor === Array) {
                this.params = [];
                for (let item of data["params"])
                    this.params.push(IndicatorParam.fromJS(item, _mappings));
            }
            this.chartType = data["chartType"];
        }
    }

    static fromJS(data: any, _mappings?: any): Indicator {
        return createInstance<Indicator>(data, _mappings, Indicator);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicatorId"] = this.indicatorId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["period"] = this.period;
        data["jsonParams"] = this.jsonParams;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["deleted"] = this.deleted;
        data["global"] = this.global;
        data["chartPlotNumber"] = this.chartPlotNumber;
        data["chartColor"] = this.chartColor;
        if (this.params && this.params.constructor === Array) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        data["chartType"] = this.chartType;
        return data; 
    }
}

export interface IIndicator {
    indicatorId: number;
    name?: string | undefined;
    description?: string | undefined;
    period: QuotePeriod;
    jsonParams?: string | undefined;
    lastUpdated: Date;
    deleted: boolean;
    global: boolean;
    chartPlotNumber: number;
    chartColor?: string | undefined;
    params?: IndicatorParam[] | undefined;
    chartType: ChartType;
}

export enum QuotePeriod {
    Daily = <any>"Daily", 
    Weekly = <any>"Weekly", 
}

export class IndicatorParam implements IIndicatorParam {
    paramName?: string | undefined;
    value: number;

    constructor(data?: IIndicatorParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.paramName = data["paramName"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any, _mappings?: any): IndicatorParam {
        return createInstance<IndicatorParam>(data, _mappings, IndicatorParam);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paramName"] = this.paramName;
        data["value"] = this.value;
        return data; 
    }
}

export interface IIndicatorParam {
    paramName?: string | undefined;
    value: number;
}

export enum ChartType {
    OHLC = <any>"OHLC", 
    Line = <any>"Line", 
    Column = <any>"Column", 
}

export class IndicatorCore implements IIndicatorCore {
    name?: string | undefined;
    id: number;
    period: QuotePeriod;

    constructor(data?: IIndicatorCore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
            this.period = data["period"];
        }
    }

    static fromJS(data: any, _mappings?: any): IndicatorCore {
        return createInstance<IndicatorCore>(data, _mappings, IndicatorCore);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["period"] = this.period;
        return data; 
    }
}

export interface IIndicatorCore {
    name?: string | undefined;
    id: number;
    period: QuotePeriod;
}

export class ScheduledJob implements IScheduledJob {
    jobId: number;
    jobType: ScheduledJobType;
    startDate: Date;
    completedDate?: Date | undefined;
    jobName?: string | undefined;
    status: JobStatus;
    progress: number;

    constructor(data?: IScheduledJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.jobId = data["jobId"];
            this.jobType = data["jobType"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.completedDate = data["completedDate"] ? new Date(data["completedDate"].toString()) : <any>undefined;
            this.jobName = data["jobName"];
            this.status = data["status"];
            this.progress = data["progress"];
        }
    }

    static fromJS(data: any, _mappings?: any): ScheduledJob {
        return createInstance<ScheduledJob>(data, _mappings, ScheduledJob);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["jobType"] = this.jobType;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["jobName"] = this.jobName;
        data["status"] = this.status;
        data["progress"] = this.progress;
        return data; 
    }
}

export interface IScheduledJob {
    jobId: number;
    jobType: ScheduledJobType;
    startDate: Date;
    completedDate?: Date | undefined;
    jobName?: string | undefined;
    status: JobStatus;
    progress: number;
}

export enum ScheduledJobType {
    All = <any>"All", 
    RefreshAllStocks = <any>"RefreshAllStocks", 
    RefreshSP500Stocks = <any>"RefreshSP500Stocks", 
    CalculateGlobalIndicators = <any>"CalculateGlobalIndicators", 
    RefreshIndices = <any>"RefreshIndices", 
}

export enum JobStatus {
    Pending = <any>"Pending", 
    InProgress = <any>"InProgress", 
    Completed = <any>"Completed", 
    Cancelled = <any>"Cancelled", 
    Paused = <any>"Paused", 
    Error = <any>"Error", 
}

export class ChartLayoutModel implements IChartLayoutModel {
    plots?: ChartPlotModel[] | undefined;
    layoutId: number;
    title?: string | undefined;
    description?: string | undefined;
    deleted: boolean;
    period: QuotePeriod;
    default: boolean;

    constructor(data?: IChartLayoutModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["plots"] && data["plots"].constructor === Array) {
                this.plots = [];
                for (let item of data["plots"])
                    this.plots.push(ChartPlotModel.fromJS(item, _mappings));
            }
            this.layoutId = data["layoutId"];
            this.title = data["title"];
            this.description = data["description"];
            this.deleted = data["deleted"];
            this.period = data["period"];
            this.default = data["default"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChartLayoutModel {
        return createInstance<ChartLayoutModel>(data, _mappings, ChartLayoutModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.plots && this.plots.constructor === Array) {
            data["plots"] = [];
            for (let item of this.plots)
                data["plots"].push(item.toJSON());
        }
        data["layoutId"] = this.layoutId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["deleted"] = this.deleted;
        data["period"] = this.period;
        data["default"] = this.default;
        return data; 
    }
}

export interface IChartLayoutModel {
    plots?: ChartPlotModel[] | undefined;
    layoutId: number;
    title?: string | undefined;
    description?: string | undefined;
    deleted: boolean;
    period: QuotePeriod;
    default: boolean;
}

export class ChartPlotModel implements IChartPlotModel {
    layoutId: number;
    plotId: number;
    orderId: number;
    height: number;
    indicators?: LayoutIndicatorModel[] | undefined;

    constructor(data?: IChartPlotModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.layoutId = data["layoutId"];
            this.plotId = data["plotId"];
            this.orderId = data["orderId"];
            this.height = data["height"];
            if (data["indicators"] && data["indicators"].constructor === Array) {
                this.indicators = [];
                for (let item of data["indicators"])
                    this.indicators.push(LayoutIndicatorModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ChartPlotModel {
        return createInstance<ChartPlotModel>(data, _mappings, ChartPlotModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutId"] = this.layoutId;
        data["plotId"] = this.plotId;
        data["orderId"] = this.orderId;
        data["height"] = this.height;
        if (this.indicators && this.indicators.constructor === Array) {
            data["indicators"] = [];
            for (let item of this.indicators)
                data["indicators"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChartPlotModel {
    layoutId: number;
    plotId: number;
    orderId: number;
    height: number;
    indicators?: LayoutIndicatorModel[] | undefined;
}

export class LayoutIndicatorModel implements ILayoutIndicatorModel {
    id: number;
    plotId: number;
    indicatorId: number;
    orderId: number;
    indicator?: IndicatorModel | undefined;
    name?: string | undefined;
    lineColor?: string | undefined;

    constructor(data?: ILayoutIndicatorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.id = data["id"];
            this.plotId = data["plotId"];
            this.indicatorId = data["indicatorId"];
            this.orderId = data["orderId"];
            this.indicator = data["indicator"] ? IndicatorModel.fromJS(data["indicator"], _mappings) : <any>undefined;
            this.name = data["name"];
            this.lineColor = data["lineColor"];
        }
    }

    static fromJS(data: any, _mappings?: any): LayoutIndicatorModel {
        return createInstance<LayoutIndicatorModel>(data, _mappings, LayoutIndicatorModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plotId"] = this.plotId;
        data["indicatorId"] = this.indicatorId;
        data["orderId"] = this.orderId;
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["lineColor"] = this.lineColor;
        return data; 
    }
}

export interface ILayoutIndicatorModel {
    id: number;
    plotId: number;
    indicatorId: number;
    orderId: number;
    indicator?: IndicatorModel | undefined;
    name?: string | undefined;
    lineColor?: string | undefined;
}

export class IndicatorModel implements IIndicatorModel {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | undefined;
    name?: string | undefined;
    jsonParams?: string | undefined;
    description?: string | undefined;

    constructor(data?: IIndicatorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.indicatorId = data["indicatorId"];
            this.period = data["period"];
            if (data["params"] && data["params"].constructor === Array) {
                this.params = [];
                for (let item of data["params"])
                    this.params.push(IndicatorParam.fromJS(item, _mappings));
            }
            this.name = data["name"];
            this.jsonParams = data["jsonParams"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): IndicatorModel {
        return createInstance<IndicatorModel>(data, _mappings, IndicatorModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicatorId"] = this.indicatorId;
        data["period"] = this.period;
        if (this.params && this.params.constructor === Array) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["jsonParams"] = this.jsonParams;
        data["description"] = this.description;
        return data; 
    }
}

export interface IIndicatorModel {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | undefined;
    name?: string | undefined;
    jsonParams?: string | undefined;
    description?: string | undefined;
}

export class ProcessorLog implements IProcessorLog {
    id: number;
    logged: Date;
    level?: string | undefined;
    message?: string | undefined;
    processor?: string | undefined;
    jobType?: string | undefined;
    jobState?: string | undefined;
    exception?: string | undefined;
    jobId: number;

    constructor(data?: IProcessorLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.id = data["id"];
            this.logged = data["logged"] ? new Date(data["logged"].toString()) : <any>undefined;
            this.level = data["level"];
            this.message = data["message"];
            this.processor = data["processor"];
            this.jobType = data["jobType"];
            this.jobState = data["jobState"];
            this.exception = data["exception"];
            this.jobId = data["jobId"];
        }
    }

    static fromJS(data: any, _mappings?: any): ProcessorLog {
        return createInstance<ProcessorLog>(data, _mappings, ProcessorLog);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["logged"] = this.logged ? this.logged.toISOString() : <any>undefined;
        data["level"] = this.level;
        data["message"] = this.message;
        data["processor"] = this.processor;
        data["jobType"] = this.jobType;
        data["jobState"] = this.jobState;
        data["exception"] = this.exception;
        data["jobId"] = this.jobId;
        return data; 
    }
}

export interface IProcessorLog {
    id: number;
    logged: Date;
    level?: string | undefined;
    message?: string | undefined;
    processor?: string | undefined;
    jobType?: string | undefined;
    jobState?: string | undefined;
    exception?: string | undefined;
    jobId: number;
}

export class Rule implements IRule {
    ruleId: number;
    name?: string | undefined;
    description?: string | undefined;
    deleted: boolean;
    period: QuotePeriod;
    dataSourceV1: DataSourceType;
    dataSourceV2: DataSourceType;
    dataSeriesV1: number;
    dataSeriesV2: number;
    constV1?: string | undefined;
    constV2?: string | undefined;
    skipItemsV1: number;
    skipItemsV2: number;
    takeItemsV1: number;
    takeItemsV2: number;
    transformItemsV1: TransformFunction;
    transformItemsV2: TransformFunction;
    condition: CompareOperator;

    constructor(data?: IRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.ruleId = data["ruleId"];
            this.name = data["name"];
            this.description = data["description"];
            this.deleted = data["deleted"];
            this.period = data["period"];
            this.dataSourceV1 = data["dataSourceV1"];
            this.dataSourceV2 = data["dataSourceV2"];
            this.dataSeriesV1 = data["dataSeriesV1"];
            this.dataSeriesV2 = data["dataSeriesV2"];
            this.constV1 = data["constV1"];
            this.constV2 = data["constV2"];
            this.skipItemsV1 = data["skipItemsV1"];
            this.skipItemsV2 = data["skipItemsV2"];
            this.takeItemsV1 = data["takeItemsV1"];
            this.takeItemsV2 = data["takeItemsV2"];
            this.transformItemsV1 = data["transformItemsV1"];
            this.transformItemsV2 = data["transformItemsV2"];
            this.condition = data["condition"];
        }
    }

    static fromJS(data: any, _mappings?: any): Rule {
        return createInstance<Rule>(data, _mappings, Rule);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["deleted"] = this.deleted;
        data["period"] = this.period;
        data["dataSourceV1"] = this.dataSourceV1;
        data["dataSourceV2"] = this.dataSourceV2;
        data["dataSeriesV1"] = this.dataSeriesV1;
        data["dataSeriesV2"] = this.dataSeriesV2;
        data["constV1"] = this.constV1;
        data["constV2"] = this.constV2;
        data["skipItemsV1"] = this.skipItemsV1;
        data["skipItemsV2"] = this.skipItemsV2;
        data["takeItemsV1"] = this.takeItemsV1;
        data["takeItemsV2"] = this.takeItemsV2;
        data["transformItemsV1"] = this.transformItemsV1;
        data["transformItemsV2"] = this.transformItemsV2;
        data["condition"] = this.condition;
        return data; 
    }
}

export interface IRule {
    ruleId: number;
    name?: string | undefined;
    description?: string | undefined;
    deleted: boolean;
    period: QuotePeriod;
    dataSourceV1: DataSourceType;
    dataSourceV2: DataSourceType;
    dataSeriesV1: number;
    dataSeriesV2: number;
    constV1?: string | undefined;
    constV2?: string | undefined;
    skipItemsV1: number;
    skipItemsV2: number;
    takeItemsV1: number;
    takeItemsV2: number;
    transformItemsV1: TransformFunction;
    transformItemsV2: TransformFunction;
    condition: CompareOperator;
}

export enum DataSourceType {
    Indicator = <any>"Indicator", 
    HistoricalData = <any>"HistoricalData", 
    Constant = <any>"Constant", 
}

export enum TransformFunction {
    First = <any>"First", 
    Max = <any>"Max", 
    Sum = <any>"Sum", 
    Avg = <any>"Avg", 
    Min = <any>"Min", 
}

export enum CompareOperator {
    Greater = <any>"Greater", 
    GreaterOrEqual = <any>"GreaterOrEqual", 
    Equal = <any>"Equal", 
    Less = <any>"Less", 
    LessOrEqual = <any>"LessOrEqual", 
    NotEqual = <any>"NotEqual", 
}

export class RuleSetModel implements IRuleSetModel {
    rules?: RuleModel[] | undefined;
    period: QuotePeriod;
    ruleSetId: number;
    name?: string | undefined;
    deleted: boolean;
    description?: string | undefined;

    constructor(data?: IRuleSetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(RuleModel.fromJS(item, _mappings));
            }
            this.period = data["period"];
            this.ruleSetId = data["ruleSetId"];
            this.name = data["name"];
            this.deleted = data["deleted"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): RuleSetModel {
        return createInstance<RuleSetModel>(data, _mappings, RuleSetModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["period"] = this.period;
        data["ruleSetId"] = this.ruleSetId;
        data["name"] = this.name;
        data["deleted"] = this.deleted;
        data["description"] = this.description;
        return data; 
    }
}

export interface IRuleSetModel {
    rules?: RuleModel[] | undefined;
    period: QuotePeriod;
    ruleSetId: number;
    name?: string | undefined;
    deleted: boolean;
    description?: string | undefined;
}

export class RuleModel implements IRuleModel {
    name?: string | undefined;
    ruleId: number;
    ruleSetId: number;
    orderId: number;
    description?: string | undefined;
    deleted: boolean;

    constructor(data?: IRuleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.name = data["name"];
            this.ruleId = data["ruleId"];
            this.ruleSetId = data["ruleSetId"];
            this.orderId = data["orderId"];
            this.description = data["description"];
            this.deleted = data["deleted"];
        }
    }

    static fromJS(data: any, _mappings?: any): RuleModel {
        return createInstance<RuleModel>(data, _mappings, RuleModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ruleId"] = this.ruleId;
        data["ruleSetId"] = this.ruleSetId;
        data["orderId"] = this.orderId;
        data["description"] = this.description;
        data["deleted"] = this.deleted;
        return data; 
    }
}

export interface IRuleModel {
    name?: string | undefined;
    ruleId: number;
    ruleSetId: number;
    orderId: number;
    description?: string | undefined;
    deleted: boolean;
}

export class VStrategyRuleSet implements IVStrategyRuleSet {
    strategyId: number;
    strategyActive: boolean;
    ruleSetId: number;
    ruleSetName?: string | undefined;
    ruleSetDescription?: string | undefined;
    ruleSetPeriod: number;
    ruleSetOrderId: number;
    ruleSetOptional: boolean;

    constructor(data?: IVStrategyRuleSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.strategyId = data["strategyId"];
            this.strategyActive = data["strategyActive"];
            this.ruleSetId = data["ruleSetId"];
            this.ruleSetName = data["ruleSetName"];
            this.ruleSetDescription = data["ruleSetDescription"];
            this.ruleSetPeriod = data["ruleSetPeriod"];
            this.ruleSetOrderId = data["ruleSetOrderId"];
            this.ruleSetOptional = data["ruleSetOptional"];
        }
    }

    static fromJS(data: any, _mappings?: any): VStrategyRuleSet {
        return createInstance<VStrategyRuleSet>(data, _mappings, VStrategyRuleSet);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strategyId"] = this.strategyId;
        data["strategyActive"] = this.strategyActive;
        data["ruleSetId"] = this.ruleSetId;
        data["ruleSetName"] = this.ruleSetName;
        data["ruleSetDescription"] = this.ruleSetDescription;
        data["ruleSetPeriod"] = this.ruleSetPeriod;
        data["ruleSetOrderId"] = this.ruleSetOrderId;
        data["ruleSetOptional"] = this.ruleSetOptional;
        return data; 
    }
}

export interface IVStrategyRuleSet {
    strategyId: number;
    strategyActive: boolean;
    ruleSetId: number;
    ruleSetName?: string | undefined;
    ruleSetDescription?: string | undefined;
    ruleSetPeriod: number;
    ruleSetOrderId: number;
    ruleSetOptional: boolean;
}

export class GlobalIndexChartData implements IGlobalIndexChartData {
    periods?: ChartData[] | undefined;
    company?: CompanyInfo | undefined;

    constructor(data?: IGlobalIndexChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["periods"] && data["periods"].constructor === Array) {
                this.periods = [];
                for (let item of data["periods"])
                    this.periods.push(ChartData.fromJS(item, _mappings));
            }
            this.company = data["company"] ? CompanyInfo.fromJS(data["company"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GlobalIndexChartData {
        return createInstance<GlobalIndexChartData>(data, _mappings, GlobalIndexChartData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.periods && this.periods.constructor === Array) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item.toJSON());
        }
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGlobalIndexChartData {
    periods?: ChartData[] | undefined;
    company?: CompanyInfo | undefined;
}

export class CompanyChartData extends GlobalIndexChartData implements ICompanyChartData {
    ruleSets?: StrategyRuleSetResult[] | undefined;

    constructor(data?: ICompanyChartData) {
        super(data);
    }

    init(data?: any, _mappings?: any) {
        super.init(data);
        if (data) {
            if (data["ruleSets"] && data["ruleSets"].constructor === Array) {
                this.ruleSets = [];
                for (let item of data["ruleSets"])
                    this.ruleSets.push(StrategyRuleSetResult.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CompanyChartData {
        return createInstance<CompanyChartData>(data, _mappings, CompanyChartData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleSets && this.ruleSets.constructor === Array) {
            data["ruleSets"] = [];
            for (let item of this.ruleSets)
                data["ruleSets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICompanyChartData extends IGlobalIndexChartData {
    ruleSets?: StrategyRuleSetResult[] | undefined;
}

export class StrategyRuleSetResult implements IStrategyRuleSetResult {
    ruleSetId: number;
    name?: string | undefined;
    progress: number;
    rules?: StrategyRuleResult[] | undefined;

    constructor(data?: IStrategyRuleSetResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.ruleSetId = data["ruleSetId"];
            this.name = data["name"];
            this.progress = data["progress"];
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(StrategyRuleResult.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): StrategyRuleSetResult {
        return createInstance<StrategyRuleSetResult>(data, _mappings, StrategyRuleSetResult);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleSetId"] = this.ruleSetId;
        data["name"] = this.name;
        data["progress"] = this.progress;
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStrategyRuleSetResult {
    ruleSetId: number;
    name?: string | undefined;
    progress: number;
    rules?: StrategyRuleResult[] | undefined;
}

export class StrategyRuleResult implements IStrategyRuleResult {
    condition: CompareOperator;
    ruleSetId: number;
    ruleId: number;
    ruleName?: string | undefined;
    ruleSetName?: string | undefined;
    firstValue: number;
    secondValue: number;
    valid: boolean;

    constructor(data?: IStrategyRuleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.condition = data["condition"];
            this.ruleSetId = data["ruleSetId"];
            this.ruleId = data["ruleId"];
            this.ruleName = data["ruleName"];
            this.ruleSetName = data["ruleSetName"];
            this.firstValue = data["firstValue"];
            this.secondValue = data["secondValue"];
            this.valid = data["valid"];
        }
    }

    static fromJS(data: any, _mappings?: any): StrategyRuleResult {
        return createInstance<StrategyRuleResult>(data, _mappings, StrategyRuleResult);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condition"] = this.condition;
        data["ruleSetId"] = this.ruleSetId;
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        data["ruleSetName"] = this.ruleSetName;
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["valid"] = this.valid;
        return data; 
    }
}

export interface IStrategyRuleResult {
    condition: CompareOperator;
    ruleSetId: number;
    ruleId: number;
    ruleName?: string | undefined;
    ruleSetName?: string | undefined;
    firstValue: number;
    secondValue: number;
    valid: boolean;
}

export class ChartData implements IChartData {
    quotes?: QuotesModel[] | undefined;
    indicators?: IndicatorChartData[] | undefined;
    period: QuotePeriod;
    name?: string | undefined;

    constructor(data?: IChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["quotes"] && data["quotes"].constructor === Array) {
                this.quotes = [];
                for (let item of data["quotes"])
                    this.quotes.push(QuotesModel.fromJS(item, _mappings));
            }
            if (data["indicators"] && data["indicators"].constructor === Array) {
                this.indicators = [];
                for (let item of data["indicators"])
                    this.indicators.push(IndicatorChartData.fromJS(item, _mappings));
            }
            this.period = data["period"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChartData {
        return createInstance<ChartData>(data, _mappings, ChartData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.quotes && this.quotes.constructor === Array) {
            data["quotes"] = [];
            for (let item of this.quotes)
                data["quotes"].push(item.toJSON());
        }
        if (this.indicators && this.indicators.constructor === Array) {
            data["indicators"] = [];
            for (let item of this.indicators)
                data["indicators"].push(item.toJSON());
        }
        data["period"] = this.period;
        data["name"] = this.name;
        return data; 
    }
}

export interface IChartData {
    quotes?: QuotesModel[] | undefined;
    indicators?: IndicatorChartData[] | undefined;
    period: QuotePeriod;
    name?: string | undefined;
}

export class IndicatorChartData implements IIndicatorChartData {
    indicator?: IIndicatorEntity | undefined;
    indicatorValues?: IndicatorResult[] | undefined;

    constructor(data?: IIndicatorChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.indicator = data["indicator"] ? IIndicatorEntity.fromJS(data["indicator"], _mappings) : <any>undefined;
            if (data["indicatorValues"] && data["indicatorValues"].constructor === Array) {
                this.indicatorValues = [];
                for (let item of data["indicatorValues"])
                    this.indicatorValues.push(IndicatorResult.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): IndicatorChartData {
        return createInstance<IndicatorChartData>(data, _mappings, IndicatorChartData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>undefined;
        if (this.indicatorValues && this.indicatorValues.constructor === Array) {
            data["indicatorValues"] = [];
            for (let item of this.indicatorValues)
                data["indicatorValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIndicatorChartData {
    indicator?: IIndicatorEntity | undefined;
    indicatorValues?: IndicatorResult[] | undefined;
}

export class IIndicatorEntity implements IIIndicatorEntity {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | undefined;
    name?: string | undefined;
    jsonParams?: string | undefined;
    description?: string | undefined;

    constructor(data?: IIIndicatorEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.indicatorId = data["indicatorId"];
            this.period = data["period"];
            if (data["params"] && data["params"].constructor === Array) {
                this.params = [];
                for (let item of data["params"])
                    this.params.push(IndicatorParam.fromJS(item, _mappings));
            }
            this.name = data["name"];
            this.jsonParams = data["jsonParams"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): IIndicatorEntity {
        return createInstance<IIndicatorEntity>(data, _mappings, IIndicatorEntity);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicatorId"] = this.indicatorId;
        data["period"] = this.period;
        if (this.params && this.params.constructor === Array) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["jsonParams"] = this.jsonParams;
        data["description"] = this.description;
        return data; 
    }
}

export interface IIIndicatorEntity {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | undefined;
    name?: string | undefined;
    jsonParams?: string | undefined;
    description?: string | undefined;
}

export class IndicatorResult implements IIndicatorResult {
    date: Date;
    values?: IndicatorValueItem[] | undefined;

    constructor(data?: IIndicatorResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(IndicatorValueItem.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): IndicatorResult {
        return createInstance<IndicatorResult>(data, _mappings, IndicatorResult);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIndicatorResult {
    date: Date;
    values?: IndicatorValueItem[] | undefined;
}

export class IndicatorValueItem implements IIndicatorValueItem {
    kind: ValueKind;
    name?: string | undefined;
    value: number;
    lineColor?: string | undefined;
    chartType: ChartType;

    constructor(data?: IIndicatorValueItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.kind = data["kind"];
            this.name = data["name"];
            this.value = data["value"];
            this.lineColor = data["lineColor"];
            this.chartType = data["chartType"];
        }
    }

    static fromJS(data: any, _mappings?: any): IndicatorValueItem {
        return createInstance<IndicatorValueItem>(data, _mappings, IndicatorValueItem);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lineColor"] = this.lineColor;
        data["chartType"] = this.chartType;
        return data; 
    }
}

export interface IIndicatorValueItem {
    kind: ValueKind;
    name?: string | undefined;
    value: number;
    lineColor?: string | undefined;
    chartType: ChartType;
}

export enum ValueKind {
    Value = <any>"Value", 
    NewNigh = <any>"NewNigh", 
    NewLow = <any>"NewLow", 
    UpperBand = <any>"UpperBand", 
    LowerBand = <any>"LowerBand", 
}

export class CompanyInfo implements ICompanyInfo {
    ticker?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICompanyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.ticker = data["ticker"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): CompanyInfo {
        return createInstance<CompanyInfo>(data, _mappings, CompanyInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICompanyInfo {
    ticker?: string | undefined;
    name?: string | undefined;
}

export class StrategySummary implements IStrategySummary {
    active: boolean;
    url?: string | undefined;
    summary?: string | undefined;
    strategyId: number;
    title?: string | undefined;

    constructor(data?: IStrategySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.active = data["active"];
            this.url = data["url"];
            this.summary = data["summary"];
            this.strategyId = data["strategyId"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any, _mappings?: any): StrategySummary {
        return createInstance<StrategySummary>(data, _mappings, StrategySummary);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["url"] = this.url;
        data["summary"] = this.summary;
        data["strategyId"] = this.strategyId;
        data["title"] = this.title;
        return data; 
    }
}

export interface IStrategySummary {
    active: boolean;
    url?: string | undefined;
    summary?: string | undefined;
    strategyId: number;
    title?: string | undefined;
}

export class StrategyModel implements IStrategyModel {
    ruleSets?: StrategyRuleSetModel[] | undefined;
    blocks?: any[] | undefined;
    strategyId: number;
    title?: string | undefined;
    deleted: boolean;
    summary?: string | undefined;
    active: boolean;
    url?: string | undefined;

    constructor(data?: IStrategyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["ruleSets"] && data["ruleSets"].constructor === Array) {
                this.ruleSets = [];
                for (let item of data["ruleSets"])
                    this.ruleSets.push(StrategyRuleSetModel.fromJS(item, _mappings));
            }
            if (data["blocks"] && data["blocks"].constructor === Array) {
                this.blocks = [];
                for (let item of data["blocks"])
                    this.blocks.push(item);
            }
            this.strategyId = data["strategyId"];
            this.title = data["title"];
            this.deleted = data["deleted"];
            this.summary = data["summary"];
            this.active = data["active"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any, _mappings?: any): StrategyModel {
        return createInstance<StrategyModel>(data, _mappings, StrategyModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleSets && this.ruleSets.constructor === Array) {
            data["ruleSets"] = [];
            for (let item of this.ruleSets)
                data["ruleSets"].push(item.toJSON());
        }
        if (this.blocks && this.blocks.constructor === Array) {
            data["blocks"] = [];
            for (let item of this.blocks)
                data["blocks"].push(item);
        }
        data["strategyId"] = this.strategyId;
        data["title"] = this.title;
        data["deleted"] = this.deleted;
        data["summary"] = this.summary;
        data["active"] = this.active;
        data["url"] = this.url;
        return data; 
    }
}

export interface IStrategyModel {
    ruleSets?: StrategyRuleSetModel[] | undefined;
    blocks?: any[] | undefined;
    strategyId: number;
    title?: string | undefined;
    deleted: boolean;
    summary?: string | undefined;
    active: boolean;
    url?: string | undefined;
}

export class StrategyRuleSetModel implements IStrategyRuleSetModel {
    rules?: StrategyRuleModel[] | undefined;
    description?: string | undefined;
    name?: string | undefined;
    optional: boolean;
    orderId: number;
    period: number;
    ruleSetId: number;

    constructor(data?: IStrategyRuleSetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(StrategyRuleModel.fromJS(item, _mappings));
            }
            this.description = data["description"];
            this.name = data["name"];
            this.optional = data["optional"];
            this.orderId = data["orderId"];
            this.period = data["period"];
            this.ruleSetId = data["ruleSetId"];
        }
    }

    static fromJS(data: any, _mappings?: any): StrategyRuleSetModel {
        return createInstance<StrategyRuleSetModel>(data, _mappings, StrategyRuleSetModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["name"] = this.name;
        data["optional"] = this.optional;
        data["orderId"] = this.orderId;
        data["period"] = this.period;
        data["ruleSetId"] = this.ruleSetId;
        return data; 
    }
}

export interface IStrategyRuleSetModel {
    rules?: StrategyRuleModel[] | undefined;
    description?: string | undefined;
    name?: string | undefined;
    optional: boolean;
    orderId: number;
    period: number;
    ruleSetId: number;
}

export class StrategyRuleModel implements IStrategyRuleModel {

    constructor(data?: IStrategyRuleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
        }
    }

    static fromJS(data: any, _mappings?: any): StrategyRuleModel {
        return createInstance<StrategyRuleModel>(data, _mappings, StrategyRuleModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IStrategyRuleModel {
}

export class Strategy implements IStrategy {
    strategyId: number;
    name?: string | undefined;
    url?: string | undefined;
    jsonArticleBlocks?: string | undefined;
    description?: string | undefined;
    deleted: boolean;
    active: boolean;

    constructor(data?: IStrategy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.strategyId = data["strategyId"];
            this.name = data["name"];
            this.url = data["url"];
            this.jsonArticleBlocks = data["jsonArticleBlocks"];
            this.description = data["description"];
            this.deleted = data["deleted"];
            this.active = data["active"];
        }
    }

    static fromJS(data: any, _mappings?: any): Strategy {
        return createInstance<Strategy>(data, _mappings, Strategy);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strategyId"] = this.strategyId;
        data["name"] = this.name;
        data["url"] = this.url;
        data["jsonArticleBlocks"] = this.jsonArticleBlocks;
        data["description"] = this.description;
        data["deleted"] = this.deleted;
        data["active"] = this.active;
        return data; 
    }
}

export interface IStrategy {
    strategyId: number;
    name?: string | undefined;
    url?: string | undefined;
    jsonArticleBlocks?: string | undefined;
    description?: string | undefined;
    deleted: boolean;
    active: boolean;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, null);
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}