/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v10.6.6324.28497 (NJsonSchema v8.33.6323.36213) (http://NSwag.org)
// </auto-generated>
//----------------------

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';

export interface IArticlesApiClient {
    getArticle(id: number): Promise<ArticleModel | null>;
    deleteArticle(id: number): Promise<Blob | null>;
    updateArticleOrder(model: UpdateArticleOrderModel): Promise<Blob | null>;
    deleteCategory(id: number): Promise<Blob | null>;
    getSection(sectionUrl: string): Promise<SectionModel | null>;
    getSections(): Promise<SectionModel[] | null>;
    getFeaturedArticle(categoryId: number): Promise<ArticleModel | null>;
    getArticleByUrl(categoryId: number, articleUrl: string): Promise<ArticleModel | null>;
    getArticles(categoryId: number): Promise<ArticleHeader[] | null>;
    setFeaturedArticle(id: number): Promise<Blob | null>;
    getCategories(sectionId: number): Promise<CategoryModel[] | null>;
    getCategory(categoryUrl: string): Promise<CategoryModel | null>;
    saveArticle(model: ArticleModel): Promise<ArticleModel | null>;
    saveCategory(model: CategoryModel): Promise<CategoryModel | null>;
}

@inject(String, HttpClient)
export class ArticlesApiClient implements IArticlesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getArticle(id: number): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticle(_response);
        });
    }

    protected processGetArticle(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    deleteArticle(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteArticle(_response);
        });
    }

    protected processDeleteArticle(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    updateArticleOrder(model: UpdateArticleOrderModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article//order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateArticleOrder(_response);
        });
    }

    protected processUpdateArticleOrder(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    deleteCategory(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getSection(sectionUrl: string): Promise<SectionModel | null> {
        let url_ = this.baseUrl + "/api/article/section/{sectionUrl}";
        if (sectionUrl === undefined || sectionUrl === null)
            throw new Error("The parameter 'sectionUrl' must be defined.");
        url_ = url_.replace("{sectionUrl}", encodeURIComponent("" + sectionUrl)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSection(_response);
        });
    }

    protected processGetSection(response: Response): Promise<SectionModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: SectionModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? SectionModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<SectionModel | null>(<any>null);
    }

    getSections(): Promise<SectionModel[] | null> {
        let url_ = this.baseUrl + "/api/article/sections";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSections(_response);
        });
    }

    protected processGetSections(response: Response): Promise<SectionModel[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: SectionModel[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SectionModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<SectionModel[] | null>(<any>null);
    }

    getFeaturedArticle(categoryId: number): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article/{categoryId}/featured";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFeaturedArticle(_response);
        });
    }

    protected processGetFeaturedArticle(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    getArticleByUrl(categoryId: number, articleUrl: string): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article/url/{categoryId}/{articleUrl}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        if (articleUrl === undefined || articleUrl === null)
            throw new Error("The parameter 'articleUrl' must be defined.");
        url_ = url_.replace("{articleUrl}", encodeURIComponent("" + articleUrl)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticleByUrl(_response);
        });
    }

    protected processGetArticleByUrl(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    getArticles(categoryId: number): Promise<ArticleHeader[] | null> {
        let url_ = this.baseUrl + "/api/article/{categoryId}/all";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticles(_response);
        });
    }

    protected processGetArticles(response: Response): Promise<ArticleHeader[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleHeader[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ArticleHeader.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleHeader[] | null>(<any>null);
    }

    setFeaturedArticle(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/article/{id}/featured";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetFeaturedArticle(_response);
        });
    }

    protected processSetFeaturedArticle(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getCategories(sectionId: number): Promise<CategoryModel[] | null> {
        let url_ = this.baseUrl + "/api/article/categories/{sectionId}";
        if (sectionId === undefined || sectionId === null)
            throw new Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<CategoryModel[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CategoryModel[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CategoryModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CategoryModel[] | null>(<any>null);
    }

    getCategory(categoryUrl: string): Promise<CategoryModel | null> {
        let url_ = this.baseUrl + "/api/article/category/{categoryUrl}";
        if (categoryUrl === undefined || categoryUrl === null)
            throw new Error("The parameter 'categoryUrl' must be defined.");
        url_ = url_.replace("{categoryUrl}", encodeURIComponent("" + categoryUrl)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<CategoryModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CategoryModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CategoryModel | null>(<any>null);
    }

    saveArticle(model: ArticleModel): Promise<ArticleModel | null> {
        let url_ = this.baseUrl + "/api/article";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveArticle(_response);
        });
    }

    protected processSaveArticle(response: Response): Promise<ArticleModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ArticleModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArticleModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ArticleModel | null>(<any>null);
    }

    saveCategory(model: CategoryModel): Promise<CategoryModel | null> {
        let url_ = this.baseUrl + "/api/article/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveCategory(_response);
        });
    }

    protected processSaveCategory(response: Response): Promise<CategoryModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CategoryModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CategoryModel | null>(<any>null);
    }
}

export interface IBlobApiClient {
    test(): Promise<string | null>;
    uploadSingle(file: FileDetails): Promise<string | null>;
}

@inject(String, HttpClient)
export class BlobApiClient implements IBlobApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    test(): Promise<string | null> {
        let url_ = this.baseUrl + "/api/blob/monitor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: Response): Promise<string | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: string | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    uploadSingle(file: FileDetails): Promise<string | null> {
        let url_ = this.baseUrl + "/api/blob/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file ? file.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadSingle(_response);
        });
    }

    protected processUploadSingle(response: Response): Promise<string | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: string | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }
}

export interface ICompaniesApiClient {
    getCompany(ticker: string): Promise<Company | null>;
    search(request: CompanySearchRequest): Promise<CompanyDetails[] | null>;
}

@inject(String, HttpClient)
export class CompaniesApiClient implements ICompaniesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getCompany(ticker: string): Promise<Company | null> {
        let url_ = this.baseUrl + "/api/company/{ticker}";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompany(_response);
        });
    }

    protected processGetCompany(response: Response): Promise<Company | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Company | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Company.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Company | null>(<any>null);
    }

    search(request: CompanySearchRequest): Promise<CompanyDetails[] | null> {
        let url_ = this.baseUrl + "/api/company/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request ? request.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<CompanyDetails[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyDetails[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CompanyDetails.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyDetails[] | null>(<any>null);
    }
}

export interface IIndicatorsApiClient {
    getIndicator(id: number): Promise<Indicator | null>;
    deleteIndicator(id: number): Promise<Blob | null>;
    getIndicatorsAll(period: number): Promise<Indicator[] | null>;
    getIndicators(): Promise<IndicatorCore[] | null>;
    saveIndicator(model: Indicator): Promise<Indicator | null>;
}

@inject(String, HttpClient)
export class IndicatorsApiClient implements IIndicatorsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getIndicator(id: number): Promise<Indicator | null> {
        let url_ = this.baseUrl + "/api/indicator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndicator(_response);
        });
    }

    protected processGetIndicator(response: Response): Promise<Indicator | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Indicator | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Indicator.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Indicator | null>(<any>null);
    }

    deleteIndicator(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/indicator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIndicator(_response);
        });
    }

    protected processDeleteIndicator(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getIndicatorsAll(period: number): Promise<Indicator[] | null> {
        let url_ = this.baseUrl + "/api/indicator/{period}/all";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndicatorsAll(_response);
        });
    }

    protected processGetIndicatorsAll(response: Response): Promise<Indicator[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Indicator[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Indicator.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Indicator[] | null>(<any>null);
    }

    getIndicators(): Promise<IndicatorCore[] | null> {
        let url_ = this.baseUrl + "/api/indicator/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndicators(_response);
        });
    }

    protected processGetIndicators(response: Response): Promise<IndicatorCore[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: IndicatorCore[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(IndicatorCore.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<IndicatorCore[] | null>(<any>null);
    }

    saveIndicator(model: Indicator): Promise<Indicator | null> {
        let url_ = this.baseUrl + "/api/indicator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveIndicator(_response);
        });
    }

    protected processSaveIndicator(response: Response): Promise<Indicator | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Indicator | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Indicator.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Indicator | null>(<any>null);
    }
}

export interface IJobsApiClient {
    cancelScheduledJob(jobId: number): Promise<Blob | null>;
    pauseScheduledJob(jobId: number): Promise<Blob | null>;
    resumeScheduledJob(jobId: number): Promise<Blob | null>;
    clearJobsHistory(jobType: number): Promise<Blob | null>;
    deleteScheduledJob(jobId: number): Promise<Blob | null>;
    startScheduledJobs(jobType: number): Promise<ScheduledJob | null>;
    getSheduledJobHistory(jobType: number): Promise<ScheduledJob[] | null>;
    getCurrentJob(jobType: number): Promise<ScheduledJob | null>;
    getJob(jobId: number): Promise<ScheduledJob | null>;
}

@inject(String, HttpClient)
export class JobsApiClient implements IJobsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    cancelScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/cancel/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelScheduledJob(_response);
        });
    }

    protected processCancelScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    pauseScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/pause/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPauseScheduledJob(_response);
        });
    }

    protected processPauseScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    resumeScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/resume/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumeScheduledJob(_response);
        });
    }

    protected processResumeScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    clearJobsHistory(jobType: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/history/clear/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearJobsHistory(_response);
        });
    }

    protected processClearJobsHistory(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    deleteScheduledJob(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/job/delete/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteScheduledJob(_response);
        });
    }

    protected processDeleteScheduledJob(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    startScheduledJobs(jobType: number): Promise<ScheduledJob | null> {
        let url_ = this.baseUrl + "/api/job/start/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartScheduledJobs(_response);
        });
    }

    protected processStartScheduledJobs(response: Response): Promise<ScheduledJob | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduledJob.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob | null>(<any>null);
    }

    getSheduledJobHistory(jobType: number): Promise<ScheduledJob[] | null> {
        let url_ = this.baseUrl + "/api/job/history/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSheduledJobHistory(_response);
        });
    }

    protected processGetSheduledJobHistory(response: Response): Promise<ScheduledJob[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ScheduledJob.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob[] | null>(<any>null);
    }

    getCurrentJob(jobType: number): Promise<ScheduledJob | null> {
        let url_ = this.baseUrl + "/api/job/current/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentJob(_response);
        });
    }

    protected processGetCurrentJob(response: Response): Promise<ScheduledJob | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduledJob.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob | null>(<any>null);
    }

    getJob(jobId: number): Promise<ScheduledJob | null> {
        let url_ = this.baseUrl + "/api/job/info/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJob(_response);
        });
    }

    protected processGetJob(response: Response): Promise<ScheduledJob | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ScheduledJob | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduledJob.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ScheduledJob | null>(<any>null);
    }
}

export interface ILayoutApiClient {
    getLayoutsForPeriod(period: number): Promise<ChartLayoutModel[] | null>;
    getLayout(layoutId: number): Promise<ChartLayoutModel | null>;
    getDefaultLayout(period: number): Promise<ChartLayoutModel | null>;
    saveLayout(model: ChartLayoutModel): Promise<ChartLayoutModel | null>;
}

@inject(String, HttpClient)
export class LayoutApiClient implements ILayoutApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getLayoutsForPeriod(period: number): Promise<ChartLayoutModel[] | null> {
        let url_ = this.baseUrl + "/api/layout/period/{period}";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLayoutsForPeriod(_response);
        });
    }

    protected processGetLayoutsForPeriod(response: Response): Promise<ChartLayoutModel[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChartLayoutModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel[] | null>(<any>null);
    }

    getLayout(layoutId: number): Promise<ChartLayoutModel | null> {
        let url_ = this.baseUrl + "/api/layout/{layoutId}";
        if (layoutId === undefined || layoutId === null)
            throw new Error("The parameter 'layoutId' must be defined.");
        url_ = url_.replace("{layoutId}", encodeURIComponent("" + layoutId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLayout(_response);
        });
    }

    protected processGetLayout(response: Response): Promise<ChartLayoutModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChartLayoutModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel | null>(<any>null);
    }

    getDefaultLayout(period: number): Promise<ChartLayoutModel | null> {
        let url_ = this.baseUrl + "/api/layout/period/{period}/default";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefaultLayout(_response);
        });
    }

    protected processGetDefaultLayout(response: Response): Promise<ChartLayoutModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChartLayoutModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel | null>(<any>null);
    }

    saveLayout(model: ChartLayoutModel): Promise<ChartLayoutModel | null> {
        let url_ = this.baseUrl + "/api/layout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveLayout(_response);
        });
    }

    protected processSaveLayout(response: Response): Promise<ChartLayoutModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ChartLayoutModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChartLayoutModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ChartLayoutModel | null>(<any>null);
    }
}

export interface ILogsApiClient {
    getJobLogs(jobId: number): Promise<ProcessorLog[] | null>;
    deleteJobLogs(jobId: number): Promise<Blob | null>;
    deleteAllLogs(jobType: number): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class LogsApiClient implements ILogsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getJobLogs(jobId: number): Promise<ProcessorLog[] | null> {
        let url_ = this.baseUrl + "/api/logs/job/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJobLogs(_response);
        });
    }

    protected processGetJobLogs(response: Response): Promise<ProcessorLog[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: ProcessorLog[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProcessorLog.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ProcessorLog[] | null>(<any>null);
    }

    deleteJobLogs(jobId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/logs/job/delete/{jobId}";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteJobLogs(_response);
        });
    }

    protected processDeleteJobLogs(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    deleteAllLogs(jobType: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/logs/job-type/delete/{jobType}";
        if (jobType === undefined || jobType === null)
            throw new Error("The parameter 'jobType' must be defined.");
        url_ = url_.replace("{jobType}", encodeURIComponent("" + jobType)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAllLogs(_response);
        });
    }

    protected processDeleteAllLogs(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export interface IRulesApiClient {
    getRule(id: number): Promise<Rule | null>;
    deleteRule(id: number): Promise<Blob | null>;
    getRules(period: number): Promise<Rule[] | null>;
    saveRule(model: Rule): Promise<Rule | null>;
}

@inject(String, HttpClient)
export class RulesApiClient implements IRulesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getRule(id: number): Promise<Rule | null> {
        let url_ = this.baseUrl + "/api/rule/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRule(_response);
        });
    }

    protected processGetRule(response: Response): Promise<Rule | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Rule | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Rule.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Rule | null>(<any>null);
    }

    deleteRule(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/rule/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRule(_response);
        });
    }

    protected processDeleteRule(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getRules(period: number): Promise<Rule[] | null> {
        let url_ = this.baseUrl + "/api/rule/{period}/all";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRules(_response);
        });
    }

    protected processGetRules(response: Response): Promise<Rule[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Rule[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Rule.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Rule[] | null>(<any>null);
    }

    saveRule(model: Rule): Promise<Rule | null> {
        let url_ = this.baseUrl + "/api/rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveRule(_response);
        });
    }

    protected processSaveRule(response: Response): Promise<Rule | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Rule | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Rule.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Rule | null>(<any>null);
    }
}

export interface IRuleSetsApiClient {
    getRuleSet(id: number): Promise<RuleSetModel | null>;
    deleteRuleSet(id: number): Promise<Blob | null>;
    getRuleSets(period: number): Promise<RuleSetModel[] | null>;
    saveRuleSet(model: RuleSetModel): Promise<RuleSetModel | null>;
    getStrategyRuleSets(id: number): Promise<VStrategyRuleSet[] | null>;
    saveStrategyRuleSets(id: number, ruleSets: VStrategyRuleSet[]): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class RuleSetsApiClient implements IRuleSetsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getRuleSet(id: number): Promise<RuleSetModel | null> {
        let url_ = this.baseUrl + "/api/ruleset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRuleSet(_response);
        });
    }

    protected processGetRuleSet(response: Response): Promise<RuleSetModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: RuleSetModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? RuleSetModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<RuleSetModel | null>(<any>null);
    }

    deleteRuleSet(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/ruleset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRuleSet(_response);
        });
    }

    protected processDeleteRuleSet(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getRuleSets(period: number): Promise<RuleSetModel[] | null> {
        let url_ = this.baseUrl + "/api/ruleset/{period}/all";
        if (period === undefined || period === null)
            throw new Error("The parameter 'period' must be defined.");
        url_ = url_.replace("{period}", encodeURIComponent("" + period)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRuleSets(_response);
        });
    }

    protected processGetRuleSets(response: Response): Promise<RuleSetModel[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: RuleSetModel[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RuleSetModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<RuleSetModel[] | null>(<any>null);
    }

    saveRuleSet(model: RuleSetModel): Promise<RuleSetModel | null> {
        let url_ = this.baseUrl + "/api/ruleset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveRuleSet(_response);
        });
    }

    protected processSaveRuleSet(response: Response): Promise<RuleSetModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: RuleSetModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? RuleSetModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<RuleSetModel | null>(<any>null);
    }

    getStrategyRuleSets(id: number): Promise<VStrategyRuleSet[] | null> {
        let url_ = this.baseUrl + "/api/ruleset/strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategyRuleSets(_response);
        });
    }

    protected processGetStrategyRuleSets(response: Response): Promise<VStrategyRuleSet[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: VStrategyRuleSet[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(VStrategyRuleSet.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<VStrategyRuleSet[] | null>(<any>null);
    }

    saveStrategyRuleSets(id: number, ruleSets: VStrategyRuleSet[]): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/ruleset/strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let contentData_: any = [];
        if (ruleSets) {
            for (let item of ruleSets)
                contentData_.push(item.toJSON());
        }
        const content_ = JSON.stringify(ruleSets ? contentData_ : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveStrategyRuleSets(_response);
        });
    }

    protected processSaveStrategyRuleSets(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export interface IStockApiClient {
    updateQuotes(ticker: string): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class StockApiClient implements IStockApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    updateQuotes(ticker: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/stock/{ticker}/update-quotes";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateQuotes(_response);
        });
    }

    protected processUpdateQuotes(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export interface IPlaygroundApiClient {
    loadPlayground(ticker: string, strategyId: number, bars: number, date: number): Promise<CompanyChartData | null>;
    next(ticker: string, strategyId: number): Promise<CompanyChartData | null>;
    prev(ticker: string, strategyId: number): Promise<CompanyChartData | null>;
}

@inject(String, HttpClient)
export class PlaygroundApiClient implements IPlaygroundApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    loadPlayground(ticker: string, strategyId: number, bars: number, date: number): Promise<CompanyChartData | null> {
        let url_ = this.baseUrl + "/api/playground/{ticker}/{strategyId}/{bars}/{date}";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId)); 
        if (bars === undefined || bars === null)
            throw new Error("The parameter 'bars' must be defined.");
        url_ = url_.replace("{bars}", encodeURIComponent("" + bars)); 
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoadPlayground(_response);
        });
    }

    protected processLoadPlayground(response: Response): Promise<CompanyChartData | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyChartData | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyChartData.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyChartData | null>(<any>null);
    }

    next(ticker: string, strategyId: number): Promise<CompanyChartData | null> {
        let url_ = this.baseUrl + "/api/playground/{ticker}/{strategyId}/next";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNext(_response);
        });
    }

    protected processNext(response: Response): Promise<CompanyChartData | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyChartData | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyChartData.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyChartData | null>(<any>null);
    }

    prev(ticker: string, strategyId: number): Promise<CompanyChartData | null> {
        let url_ = this.baseUrl + "/api/playground/{ticker}/{strategyId}/prev";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined.");
        url_ = url_.replace("{ticker}", encodeURIComponent("" + ticker)); 
        if (strategyId === undefined || strategyId === null)
            throw new Error("The parameter 'strategyId' must be defined.");
        url_ = url_.replace("{strategyId}", encodeURIComponent("" + strategyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrev(_response);
        });
    }

    protected processPrev(response: Response): Promise<CompanyChartData | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: CompanyChartData | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyChartData.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<CompanyChartData | null>(<any>null);
    }
}

export interface IStrategiesApiClient {
    geStrategySummaries(): Promise<StrategySummary[] | null>;
    getStrategyByUrl(url: string): Promise<StrategyModel | null>;
    getStrategySummaryByUrl(url: string): Promise<StrategySummary | null>;
    getStrategyById(id: number): Promise<Strategy | null>;
    saveStrategy(model: StrategyModel): Promise<StrategyModel | null>;
    deleteStrategy(id: number): Promise<Blob | null>;
}

@inject(String, HttpClient)
export class StrategiesApiClient implements IStrategiesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    geStrategySummaries(): Promise<StrategySummary[] | null> {
        let url_ = this.baseUrl + "/api/strategy/getSummaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeStrategySummaries(_response);
        });
    }

    protected processGeStrategySummaries(response: Response): Promise<StrategySummary[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategySummary[] | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StrategySummary.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategySummary[] | null>(<any>null);
    }

    getStrategyByUrl(url: string): Promise<StrategyModel | null> {
        let url_ = this.baseUrl + "/api/strategy/getByUrl/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategyByUrl(_response);
        });
    }

    protected processGetStrategyByUrl(response: Response): Promise<StrategyModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategyModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? StrategyModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategyModel | null>(<any>null);
    }

    getStrategySummaryByUrl(url: string): Promise<StrategySummary | null> {
        let url_ = this.baseUrl + "/api/strategy/getSummaryByUrl/{url}";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined.");
        url_ = url_.replace("{url}", encodeURIComponent("" + url)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategySummaryByUrl(_response);
        });
    }

    protected processGetStrategySummaryByUrl(response: Response): Promise<StrategySummary | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategySummary | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? StrategySummary.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategySummary | null>(<any>null);
    }

    getStrategyById(id: number): Promise<Strategy | null> {
        let url_ = this.baseUrl + "/api/strategy/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStrategyById(_response);
        });
    }

    protected processGetStrategyById(response: Response): Promise<Strategy | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: Strategy | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? Strategy.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Strategy | null>(<any>null);
    }

    saveStrategy(model: StrategyModel): Promise<StrategyModel | null> {
        let url_ = this.baseUrl + "/api/strategy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model ? model.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveStrategy(_response);
        });
    }

    protected processSaveStrategy(response: Response): Promise<StrategyModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
            let result200: StrategyModel | null = null;
            let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
            result200 = resultData200 ? StrategyModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<StrategyModel | null>(<any>null);
    }

    deleteStrategy(id: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/strategy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteStrategy(_response);
        });
    }

    protected processDeleteStrategy(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
            return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export class ArticleHeader implements IArticleHeader {
    articleId: number;
    title?: string | null;
    url?: string | null;
    summary?: string | null;
    categoryId: number;
    orderId: number;
    isFeatured: boolean;
    deleted: boolean;

    constructor(data?: IArticleHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.articleId = data["articleId"] !== undefined ? data["articleId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.summary = data["summary"] !== undefined ? data["summary"] : <any>null;
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.isFeatured = data["isFeatured"] !== undefined ? data["isFeatured"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleHeader {
        let result = new ArticleHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["isFeatured"] = this.isFeatured !== undefined ? this.isFeatured : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        return data; 
    }
}

export interface IArticleHeader {
    articleId: number;
    title?: string | null;
    url?: string | null;
    summary?: string | null;
    categoryId: number;
    orderId: number;
    isFeatured: boolean;
    deleted: boolean;
}

export class ArticleModel extends ArticleHeader implements IArticleModel {
    articleBlocks?: ArticleBlock[] | null;

    constructor(data?: IArticleModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["articleBlocks"] && data["articleBlocks"].constructor === Array) {
                this.articleBlocks = [];
                for (let item of data["articleBlocks"])
                    this.articleBlocks.push(ArticleBlock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ArticleModel {
        let result = new ArticleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.articleBlocks && this.articleBlocks.constructor === Array) {
            data["articleBlocks"] = [];
            for (let item of this.articleBlocks)
                data["articleBlocks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IArticleModel extends IArticleHeader {
    articleBlocks?: ArticleBlock[] | null;
}

export class ArticleBlock implements IArticleBlock {
    valid: boolean;
    blockType: ArticleBlockType;
    text?: string | null;
    headingType?: HeadingType | null;
    imageUrl?: string | null;
    items?: ArticleBlockItem[] | null;

    constructor(data?: IArticleBlock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.valid = data["valid"] !== undefined ? data["valid"] : <any>null;
            this.blockType = data["blockType"] !== undefined ? data["blockType"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.headingType = data["headingType"] !== undefined ? data["headingType"] : <any>null;
            this.imageUrl = data["imageUrl"] !== undefined ? data["imageUrl"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ArticleBlockItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ArticleBlock {
        let result = new ArticleBlock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valid"] = this.valid !== undefined ? this.valid : <any>null;
        data["blockType"] = this.blockType !== undefined ? this.blockType : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["headingType"] = this.headingType !== undefined ? this.headingType : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IArticleBlock {
    valid: boolean;
    blockType: ArticleBlockType;
    text?: string | null;
    headingType?: HeadingType | null;
    imageUrl?: string | null;
    items?: ArticleBlockItem[] | null;
}

export enum ArticleBlockType {
    Paragraph = <any>"Paragraph", 
    Heading = <any>"Heading", 
    Image = <any>"Image", 
    List = <any>"List", 
    Unset = <any>"Unset", 
}

export enum HeadingType {
    H1 = <any>"H1", 
    H2 = <any>"H2", 
    H3 = <any>"H3", 
    H4 = <any>"H4", 
    H5 = <any>"H5", 
}

export class ArticleBlockItem implements IArticleBlockItem {
    text?: string | null;
    valid: boolean;

    constructor(data?: IArticleBlockItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.valid = data["valid"] !== undefined ? data["valid"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleBlockItem {
        let result = new ArticleBlockItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["valid"] = this.valid !== undefined ? this.valid : <any>null;
        return data; 
    }
}

export interface IArticleBlockItem {
    text?: string | null;
    valid: boolean;
}

export class UpdateArticleOrderModel implements IUpdateArticleOrderModel {
    articleId: number;
    orderId: number;

    constructor(data?: IUpdateArticleOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.articleId = data["articleId"] !== undefined ? data["articleId"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateArticleOrderModel {
        let result = new UpdateArticleOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        return data; 
    }
}

export interface IUpdateArticleOrderModel {
    articleId: number;
    orderId: number;
}

export class SectionModel implements ISectionModel {
    sectionId: number;
    title?: string | null;
    url?: string | null;
    orderId: number;
    isDeleted: boolean;

    constructor(data?: ISectionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
        }
    }

    static fromJS(data: any): SectionModel {
        let result = new SectionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        return data; 
    }
}

export interface ISectionModel {
    sectionId: number;
    title?: string | null;
    url?: string | null;
    orderId: number;
    isDeleted: boolean;
}

export class CategoryModel implements ICategoryModel {
    categoryId: number;
    title?: string | null;
    orderId: number;
    url?: string | null;
    sectionId: number;
    deleted: boolean;

    constructor(data?: ICategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryId = data["categoryId"] !== undefined ? data["categoryId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.sectionId = data["sectionId"] !== undefined ? data["sectionId"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryModel {
        let result = new CategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["sectionId"] = this.sectionId !== undefined ? this.sectionId : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        return data; 
    }
}

export interface ICategoryModel {
    categoryId: number;
    title?: string | null;
    orderId: number;
    url?: string | null;
    sectionId: number;
    deleted: boolean;
}

export class FileDetails implements IFileDetails {
    fileName?: string | null;
    fileBody?: string | null;
    category: FileCategory;

    constructor(data?: IFileDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"] !== undefined ? data["fileName"] : <any>null;
            this.fileBody = data["fileBody"] !== undefined ? data["fileBody"] : <any>null;
            this.category = data["category"] !== undefined ? data["category"] : <any>null;
        }
    }

    static fromJS(data: any): FileDetails {
        let result = new FileDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["fileBody"] = this.fileBody !== undefined ? this.fileBody : <any>null;
        data["category"] = this.category !== undefined ? this.category : <any>null;
        return data; 
    }
}

export interface IFileDetails {
    fileName?: string | null;
    fileBody?: string | null;
    category: FileCategory;
}

export enum FileCategory {
    Articles = <any>"Articles", 
    Journal = <any>"Journal", 
}

export class Company implements ICompany {
    ticker?: string | null;
    name?: string | null;
    marketCap: number;
    sector?: string | null;
    industry?: string | null;
    summaryUrl?: string | null;
    lastUpdated: Date;
    lastCalculated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    liveQuoteJson?: string | null;
    historyQuotesJson?: string | null;
    nextReportDate: Date;
    historyQuotes?: QuotesModel[] | null;
    updateSuccessful: boolean;
    updateError?: string | null;
    calculatedSuccessful: boolean;
    calculatedError?: string | null;
    filtered: boolean;
    startDate: Date;
    endDate: Date;
    sectorId: number;
    industryId: number;
    sP500: boolean;
    isIndex: boolean;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticker = data["ticker"] !== undefined ? data["ticker"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.marketCap = data["marketCap"] !== undefined ? data["marketCap"] : <any>null;
            this.sector = data["sector"] !== undefined ? data["sector"] : <any>null;
            this.industry = data["industry"] !== undefined ? data["industry"] : <any>null;
            this.summaryUrl = data["summaryUrl"] !== undefined ? data["summaryUrl"] : <any>null;
            this.lastUpdated = data["lastUpdated"] ? new Date(data["lastUpdated"].toString()) : <any>null;
            this.lastCalculated = data["lastCalculated"] ? new Date(data["lastCalculated"].toString()) : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.price = data["price"] !== undefined ? data["price"] : <any>null;
            this.highestPrice52 = data["highestPrice52"] !== undefined ? data["highestPrice52"] : <any>null;
            this.lowestPrice52 = data["lowestPrice52"] !== undefined ? data["lowestPrice52"] : <any>null;
            this.chaosPercentage = data["chaosPercentage"] !== undefined ? data["chaosPercentage"] : <any>null;
            this.liveQuoteJson = data["liveQuoteJson"] !== undefined ? data["liveQuoteJson"] : <any>null;
            this.historyQuotesJson = data["historyQuotesJson"] !== undefined ? data["historyQuotesJson"] : <any>null;
            this.nextReportDate = data["nextReportDate"] ? new Date(data["nextReportDate"].toString()) : <any>null;
            if (data["historyQuotes"] && data["historyQuotes"].constructor === Array) {
                this.historyQuotes = [];
                for (let item of data["historyQuotes"])
                    this.historyQuotes.push(QuotesModel.fromJS(item));
            }
            this.updateSuccessful = data["updateSuccessful"] !== undefined ? data["updateSuccessful"] : <any>null;
            this.updateError = data["updateError"] !== undefined ? data["updateError"] : <any>null;
            this.calculatedSuccessful = data["calculatedSuccessful"] !== undefined ? data["calculatedSuccessful"] : <any>null;
            this.calculatedError = data["calculatedError"] !== undefined ? data["calculatedError"] : <any>null;
            this.filtered = data["filtered"] !== undefined ? data["filtered"] : <any>null;
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>null;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>null;
            this.sectorId = data["sectorId"] !== undefined ? data["sectorId"] : <any>null;
            this.industryId = data["industryId"] !== undefined ? data["industryId"] : <any>null;
            this.sP500 = data["sP500"] !== undefined ? data["sP500"] : <any>null;
            this.isIndex = data["isIndex"] !== undefined ? data["isIndex"] : <any>null;
        }
    }

    static fromJS(data: any): Company {
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker !== undefined ? this.ticker : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["marketCap"] = this.marketCap !== undefined ? this.marketCap : <any>null;
        data["sector"] = this.sector !== undefined ? this.sector : <any>null;
        data["industry"] = this.industry !== undefined ? this.industry : <any>null;
        data["summaryUrl"] = this.summaryUrl !== undefined ? this.summaryUrl : <any>null;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>null;
        data["lastCalculated"] = this.lastCalculated ? this.lastCalculated.toISOString() : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["highestPrice52"] = this.highestPrice52 !== undefined ? this.highestPrice52 : <any>null;
        data["lowestPrice52"] = this.lowestPrice52 !== undefined ? this.lowestPrice52 : <any>null;
        data["chaosPercentage"] = this.chaosPercentage !== undefined ? this.chaosPercentage : <any>null;
        data["liveQuoteJson"] = this.liveQuoteJson !== undefined ? this.liveQuoteJson : <any>null;
        data["historyQuotesJson"] = this.historyQuotesJson !== undefined ? this.historyQuotesJson : <any>null;
        data["nextReportDate"] = this.nextReportDate ? this.nextReportDate.toISOString() : <any>null;
        if (this.historyQuotes && this.historyQuotes.constructor === Array) {
            data["historyQuotes"] = [];
            for (let item of this.historyQuotes)
                data["historyQuotes"].push(item.toJSON());
        }
        data["updateSuccessful"] = this.updateSuccessful !== undefined ? this.updateSuccessful : <any>null;
        data["updateError"] = this.updateError !== undefined ? this.updateError : <any>null;
        data["calculatedSuccessful"] = this.calculatedSuccessful !== undefined ? this.calculatedSuccessful : <any>null;
        data["calculatedError"] = this.calculatedError !== undefined ? this.calculatedError : <any>null;
        data["filtered"] = this.filtered !== undefined ? this.filtered : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["sectorId"] = this.sectorId !== undefined ? this.sectorId : <any>null;
        data["industryId"] = this.industryId !== undefined ? this.industryId : <any>null;
        data["sP500"] = this.sP500 !== undefined ? this.sP500 : <any>null;
        data["isIndex"] = this.isIndex !== undefined ? this.isIndex : <any>null;
        return data; 
    }
}

export interface ICompany {
    ticker?: string | null;
    name?: string | null;
    marketCap: number;
    sector?: string | null;
    industry?: string | null;
    summaryUrl?: string | null;
    lastUpdated: Date;
    lastCalculated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    liveQuoteJson?: string | null;
    historyQuotesJson?: string | null;
    nextReportDate: Date;
    historyQuotes?: QuotesModel[] | null;
    updateSuccessful: boolean;
    updateError?: string | null;
    calculatedSuccessful: boolean;
    calculatedError?: string | null;
    filtered: boolean;
    startDate: Date;
    endDate: Date;
    sectorId: number;
    industryId: number;
    sP500: boolean;
    isIndex: boolean;
}

export class QuotesModel implements IQuotesModel {
    date: Date;
    close: number;
    volume: number;
    open: number;
    high: number;
    low: number;
    volumeAsText?: string | null;
    impulse: number;

    constructor(data?: IQuotesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.close = data["close"] !== undefined ? data["close"] : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.open = data["open"] !== undefined ? data["open"] : <any>null;
            this.high = data["high"] !== undefined ? data["high"] : <any>null;
            this.low = data["low"] !== undefined ? data["low"] : <any>null;
            this.volumeAsText = data["volumeAsText"] !== undefined ? data["volumeAsText"] : <any>null;
            this.impulse = data["impulse"] !== undefined ? data["impulse"] : <any>null;
        }
    }

    static fromJS(data: any): QuotesModel {
        let result = new QuotesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["close"] = this.close !== undefined ? this.close : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["open"] = this.open !== undefined ? this.open : <any>null;
        data["high"] = this.high !== undefined ? this.high : <any>null;
        data["low"] = this.low !== undefined ? this.low : <any>null;
        data["volumeAsText"] = this.volumeAsText !== undefined ? this.volumeAsText : <any>null;
        data["impulse"] = this.impulse !== undefined ? this.impulse : <any>null;
        return data; 
    }
}

export interface IQuotesModel {
    date: Date;
    close: number;
    volume: number;
    open: number;
    high: number;
    low: number;
    volumeAsText?: string | null;
    impulse: number;
}

export class CompanySearchRequest implements ICompanySearchRequest {
    ticker?: string | null;
    maxCount: number;

    constructor(data?: ICompanySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticker = data["ticker"] !== undefined ? data["ticker"] : <any>null;
            this.maxCount = data["maxCount"] !== undefined ? data["maxCount"] : <any>null;
        }
    }

    static fromJS(data: any): CompanySearchRequest {
        let result = new CompanySearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker !== undefined ? this.ticker : <any>null;
        data["maxCount"] = this.maxCount !== undefined ? this.maxCount : <any>null;
        return data; 
    }
}

export interface ICompanySearchRequest {
    ticker?: string | null;
    maxCount: number;
}

export class CompanyDetails implements ICompanyDetails {
    ticker?: string | null;
    name?: string | null;
    sector?: string | null;
    industry?: string | null;
    summaryUrl?: string | null;
    lastUpdated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    updateSuccessful: boolean;
    filtered: boolean;

    constructor(data?: ICompanyDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticker = data["ticker"] !== undefined ? data["ticker"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.sector = data["sector"] !== undefined ? data["sector"] : <any>null;
            this.industry = data["industry"] !== undefined ? data["industry"] : <any>null;
            this.summaryUrl = data["summaryUrl"] !== undefined ? data["summaryUrl"] : <any>null;
            this.lastUpdated = data["lastUpdated"] ? new Date(data["lastUpdated"].toString()) : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.price = data["price"] !== undefined ? data["price"] : <any>null;
            this.highestPrice52 = data["highestPrice52"] !== undefined ? data["highestPrice52"] : <any>null;
            this.lowestPrice52 = data["lowestPrice52"] !== undefined ? data["lowestPrice52"] : <any>null;
            this.chaosPercentage = data["chaosPercentage"] !== undefined ? data["chaosPercentage"] : <any>null;
            this.updateSuccessful = data["updateSuccessful"] !== undefined ? data["updateSuccessful"] : <any>null;
            this.filtered = data["filtered"] !== undefined ? data["filtered"] : <any>null;
        }
    }

    static fromJS(data: any): CompanyDetails {
        let result = new CompanyDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker !== undefined ? this.ticker : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["sector"] = this.sector !== undefined ? this.sector : <any>null;
        data["industry"] = this.industry !== undefined ? this.industry : <any>null;
        data["summaryUrl"] = this.summaryUrl !== undefined ? this.summaryUrl : <any>null;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["highestPrice52"] = this.highestPrice52 !== undefined ? this.highestPrice52 : <any>null;
        data["lowestPrice52"] = this.lowestPrice52 !== undefined ? this.lowestPrice52 : <any>null;
        data["chaosPercentage"] = this.chaosPercentage !== undefined ? this.chaosPercentage : <any>null;
        data["updateSuccessful"] = this.updateSuccessful !== undefined ? this.updateSuccessful : <any>null;
        data["filtered"] = this.filtered !== undefined ? this.filtered : <any>null;
        return data; 
    }
}

export interface ICompanyDetails {
    ticker?: string | null;
    name?: string | null;
    sector?: string | null;
    industry?: string | null;
    summaryUrl?: string | null;
    lastUpdated: Date;
    volume: number;
    price: number;
    highestPrice52: number;
    lowestPrice52: number;
    chaosPercentage: number;
    updateSuccessful: boolean;
    filtered: boolean;
}

export class Indicator implements IIndicator {
    indicatorId: number;
    name?: string | null;
    description?: string | null;
    period: QuotePeriod;
    jsonParams?: string | null;
    lastUpdated: Date;
    deleted: boolean;
    global: boolean;
    chartPlotNumber: number;
    chartColor?: string | null;
    params?: IndicatorParam[] | null;
    chartType: ChartType;

    constructor(data?: IIndicator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.indicatorId = data["indicatorId"] !== undefined ? data["indicatorId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            this.jsonParams = data["jsonParams"] !== undefined ? data["jsonParams"] : <any>null;
            this.lastUpdated = data["lastUpdated"] ? new Date(data["lastUpdated"].toString()) : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.global = data["global"] !== undefined ? data["global"] : <any>null;
            this.chartPlotNumber = data["chartPlotNumber"] !== undefined ? data["chartPlotNumber"] : <any>null;
            this.chartColor = data["chartColor"] !== undefined ? data["chartColor"] : <any>null;
            if (data["params"] && data["params"].constructor === Array) {
                this.params = [];
                for (let item of data["params"])
                    this.params.push(IndicatorParam.fromJS(item));
            }
            this.chartType = data["chartType"] !== undefined ? data["chartType"] : <any>null;
        }
    }

    static fromJS(data: any): Indicator {
        let result = new Indicator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicatorId"] = this.indicatorId !== undefined ? this.indicatorId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        data["jsonParams"] = this.jsonParams !== undefined ? this.jsonParams : <any>null;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["global"] = this.global !== undefined ? this.global : <any>null;
        data["chartPlotNumber"] = this.chartPlotNumber !== undefined ? this.chartPlotNumber : <any>null;
        data["chartColor"] = this.chartColor !== undefined ? this.chartColor : <any>null;
        if (this.params && this.params.constructor === Array) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        data["chartType"] = this.chartType !== undefined ? this.chartType : <any>null;
        return data; 
    }
}

export interface IIndicator {
    indicatorId: number;
    name?: string | null;
    description?: string | null;
    period: QuotePeriod;
    jsonParams?: string | null;
    lastUpdated: Date;
    deleted: boolean;
    global: boolean;
    chartPlotNumber: number;
    chartColor?: string | null;
    params?: IndicatorParam[] | null;
    chartType: ChartType;
}

export enum QuotePeriod {
    Daily = <any>"Daily", 
    Weekly = <any>"Weekly", 
}

export class IndicatorParam implements IIndicatorParam {
    paramName?: string | null;
    value: number;

    constructor(data?: IIndicatorParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paramName = data["paramName"] !== undefined ? data["paramName"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): IndicatorParam {
        let result = new IndicatorParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paramName"] = this.paramName !== undefined ? this.paramName : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IIndicatorParam {
    paramName?: string | null;
    value: number;
}

export enum ChartType {
    OHLC = <any>"OHLC", 
    Line = <any>"Line", 
    Column = <any>"Column", 
}

export class IndicatorCore implements IIndicatorCore {
    name?: string | null;
    id: number;
    period: QuotePeriod;

    constructor(data?: IIndicatorCore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
        }
    }

    static fromJS(data: any): IndicatorCore {
        let result = new IndicatorCore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        return data; 
    }
}

export interface IIndicatorCore {
    name?: string | null;
    id: number;
    period: QuotePeriod;
}

export class ScheduledJob implements IScheduledJob {
    jobId: number;
    jobType: ScheduledJobType;
    startDate: Date;
    completedDate?: Date | null;
    jobName?: string | null;
    status: JobStatus;
    progress: number;

    constructor(data?: IScheduledJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobId = data["jobId"] !== undefined ? data["jobId"] : <any>null;
            this.jobType = data["jobType"] !== undefined ? data["jobType"] : <any>null;
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>null;
            this.completedDate = data["completedDate"] ? new Date(data["completedDate"].toString()) : <any>null;
            this.jobName = data["jobName"] !== undefined ? data["jobName"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.progress = data["progress"] !== undefined ? data["progress"] : <any>null;
        }
    }

    static fromJS(data: any): ScheduledJob {
        let result = new ScheduledJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId !== undefined ? this.jobId : <any>null;
        data["jobType"] = this.jobType !== undefined ? this.jobType : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>null;
        data["jobName"] = this.jobName !== undefined ? this.jobName : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["progress"] = this.progress !== undefined ? this.progress : <any>null;
        return data; 
    }
}

export interface IScheduledJob {
    jobId: number;
    jobType: ScheduledJobType;
    startDate: Date;
    completedDate?: Date | null;
    jobName?: string | null;
    status: JobStatus;
    progress: number;
}

export enum ScheduledJobType {
    All = <any>"All", 
    RefreshAllStocks = <any>"RefreshAllStocks", 
    RefreshSP500Stocks = <any>"RefreshSP500Stocks", 
    CalculateGlobalIndicators = <any>"CalculateGlobalIndicators", 
    RefreshIndices = <any>"RefreshIndices", 
}

export enum JobStatus {
    Pending = <any>"Pending", 
    InProgress = <any>"InProgress", 
    Completed = <any>"Completed", 
    Cancelled = <any>"Cancelled", 
    Paused = <any>"Paused", 
    Error = <any>"Error", 
}

export class ChartLayoutModel implements IChartLayoutModel {
    plots?: ChartPlotModel[] | null;
    layoutId: number;
    title?: string | null;
    description?: string | null;
    deleted: boolean;
    period: QuotePeriod;
    default: boolean;

    constructor(data?: IChartLayoutModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["plots"] && data["plots"].constructor === Array) {
                this.plots = [];
                for (let item of data["plots"])
                    this.plots.push(ChartPlotModel.fromJS(item));
            }
            this.layoutId = data["layoutId"] !== undefined ? data["layoutId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            this.default = data["default"] !== undefined ? data["default"] : <any>null;
        }
    }

    static fromJS(data: any): ChartLayoutModel {
        let result = new ChartLayoutModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.plots && this.plots.constructor === Array) {
            data["plots"] = [];
            for (let item of this.plots)
                data["plots"].push(item.toJSON());
        }
        data["layoutId"] = this.layoutId !== undefined ? this.layoutId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        data["default"] = this.default !== undefined ? this.default : <any>null;
        return data; 
    }
}

export interface IChartLayoutModel {
    plots?: ChartPlotModel[] | null;
    layoutId: number;
    title?: string | null;
    description?: string | null;
    deleted: boolean;
    period: QuotePeriod;
    default: boolean;
}

export class ChartPlotModel implements IChartPlotModel {
    layoutId: number;
    plotId: number;
    orderId: number;
    height: number;
    indicators?: LayoutIndicatorModel[] | null;

    constructor(data?: IChartPlotModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutId = data["layoutId"] !== undefined ? data["layoutId"] : <any>null;
            this.plotId = data["plotId"] !== undefined ? data["plotId"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.height = data["height"] !== undefined ? data["height"] : <any>null;
            if (data["indicators"] && data["indicators"].constructor === Array) {
                this.indicators = [];
                for (let item of data["indicators"])
                    this.indicators.push(LayoutIndicatorModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartPlotModel {
        let result = new ChartPlotModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutId"] = this.layoutId !== undefined ? this.layoutId : <any>null;
        data["plotId"] = this.plotId !== undefined ? this.plotId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["height"] = this.height !== undefined ? this.height : <any>null;
        if (this.indicators && this.indicators.constructor === Array) {
            data["indicators"] = [];
            for (let item of this.indicators)
                data["indicators"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChartPlotModel {
    layoutId: number;
    plotId: number;
    orderId: number;
    height: number;
    indicators?: LayoutIndicatorModel[] | null;
}

export class LayoutIndicatorModel implements ILayoutIndicatorModel {
    id: number;
    plotId: number;
    indicatorId: number;
    orderId: number;
    indicator?: IndicatorModel | null;
    name?: string | null;
    lineColor?: string | null;

    constructor(data?: ILayoutIndicatorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.plotId = data["plotId"] !== undefined ? data["plotId"] : <any>null;
            this.indicatorId = data["indicatorId"] !== undefined ? data["indicatorId"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.indicator = data["indicator"] ? IndicatorModel.fromJS(data["indicator"]) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.lineColor = data["lineColor"] !== undefined ? data["lineColor"] : <any>null;
        }
    }

    static fromJS(data: any): LayoutIndicatorModel {
        let result = new LayoutIndicatorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["plotId"] = this.plotId !== undefined ? this.plotId : <any>null;
        data["indicatorId"] = this.indicatorId !== undefined ? this.indicatorId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["lineColor"] = this.lineColor !== undefined ? this.lineColor : <any>null;
        return data; 
    }
}

export interface ILayoutIndicatorModel {
    id: number;
    plotId: number;
    indicatorId: number;
    orderId: number;
    indicator?: IndicatorModel | null;
    name?: string | null;
    lineColor?: string | null;
}

export class IndicatorModel implements IIndicatorModel {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | null;
    name?: string | null;
    jsonParams?: string | null;
    description?: string | null;

    constructor(data?: IIndicatorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.indicatorId = data["indicatorId"] !== undefined ? data["indicatorId"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            if (data["params"] && data["params"].constructor === Array) {
                this.params = [];
                for (let item of data["params"])
                    this.params.push(IndicatorParam.fromJS(item));
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.jsonParams = data["jsonParams"] !== undefined ? data["jsonParams"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): IndicatorModel {
        let result = new IndicatorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicatorId"] = this.indicatorId !== undefined ? this.indicatorId : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        if (this.params && this.params.constructor === Array) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["jsonParams"] = this.jsonParams !== undefined ? this.jsonParams : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IIndicatorModel {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | null;
    name?: string | null;
    jsonParams?: string | null;
    description?: string | null;
}

export class ProcessorLog implements IProcessorLog {
    id: number;
    logged: Date;
    level?: string | null;
    message?: string | null;
    processor?: string | null;
    jobType?: string | null;
    jobState?: string | null;
    exception?: string | null;
    jobId: number;

    constructor(data?: IProcessorLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.logged = data["logged"] ? new Date(data["logged"].toString()) : <any>null;
            this.level = data["level"] !== undefined ? data["level"] : <any>null;
            this.message = data["message"] !== undefined ? data["message"] : <any>null;
            this.processor = data["processor"] !== undefined ? data["processor"] : <any>null;
            this.jobType = data["jobType"] !== undefined ? data["jobType"] : <any>null;
            this.jobState = data["jobState"] !== undefined ? data["jobState"] : <any>null;
            this.exception = data["exception"] !== undefined ? data["exception"] : <any>null;
            this.jobId = data["jobId"] !== undefined ? data["jobId"] : <any>null;
        }
    }

    static fromJS(data: any): ProcessorLog {
        let result = new ProcessorLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["logged"] = this.logged ? this.logged.toISOString() : <any>null;
        data["level"] = this.level !== undefined ? this.level : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["processor"] = this.processor !== undefined ? this.processor : <any>null;
        data["jobType"] = this.jobType !== undefined ? this.jobType : <any>null;
        data["jobState"] = this.jobState !== undefined ? this.jobState : <any>null;
        data["exception"] = this.exception !== undefined ? this.exception : <any>null;
        data["jobId"] = this.jobId !== undefined ? this.jobId : <any>null;
        return data; 
    }
}

export interface IProcessorLog {
    id: number;
    logged: Date;
    level?: string | null;
    message?: string | null;
    processor?: string | null;
    jobType?: string | null;
    jobState?: string | null;
    exception?: string | null;
    jobId: number;
}

export class Rule implements IRule {
    ruleId: number;
    name?: string | null;
    description?: string | null;
    deleted: boolean;
    period: QuotePeriod;
    dataSourceV1: DataSourceType;
    dataSourceV2: DataSourceType;
    dataSeriesV1: number;
    dataSeriesV2: number;
    constV1?: string | null;
    constV2?: string | null;
    skipItemsV1: number;
    skipItemsV2: number;
    takeItemsV1: number;
    takeItemsV2: number;
    transformItemsV1: TransformFunction;
    transformItemsV2: TransformFunction;
    condition: CompareOperator;

    constructor(data?: IRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleId = data["ruleId"] !== undefined ? data["ruleId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            this.dataSourceV1 = data["dataSourceV1"] !== undefined ? data["dataSourceV1"] : <any>null;
            this.dataSourceV2 = data["dataSourceV2"] !== undefined ? data["dataSourceV2"] : <any>null;
            this.dataSeriesV1 = data["dataSeriesV1"] !== undefined ? data["dataSeriesV1"] : <any>null;
            this.dataSeriesV2 = data["dataSeriesV2"] !== undefined ? data["dataSeriesV2"] : <any>null;
            this.constV1 = data["constV1"] !== undefined ? data["constV1"] : <any>null;
            this.constV2 = data["constV2"] !== undefined ? data["constV2"] : <any>null;
            this.skipItemsV1 = data["skipItemsV1"] !== undefined ? data["skipItemsV1"] : <any>null;
            this.skipItemsV2 = data["skipItemsV2"] !== undefined ? data["skipItemsV2"] : <any>null;
            this.takeItemsV1 = data["takeItemsV1"] !== undefined ? data["takeItemsV1"] : <any>null;
            this.takeItemsV2 = data["takeItemsV2"] !== undefined ? data["takeItemsV2"] : <any>null;
            this.transformItemsV1 = data["transformItemsV1"] !== undefined ? data["transformItemsV1"] : <any>null;
            this.transformItemsV2 = data["transformItemsV2"] !== undefined ? data["transformItemsV2"] : <any>null;
            this.condition = data["condition"] !== undefined ? data["condition"] : <any>null;
        }
    }

    static fromJS(data: any): Rule {
        let result = new Rule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId !== undefined ? this.ruleId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        data["dataSourceV1"] = this.dataSourceV1 !== undefined ? this.dataSourceV1 : <any>null;
        data["dataSourceV2"] = this.dataSourceV2 !== undefined ? this.dataSourceV2 : <any>null;
        data["dataSeriesV1"] = this.dataSeriesV1 !== undefined ? this.dataSeriesV1 : <any>null;
        data["dataSeriesV2"] = this.dataSeriesV2 !== undefined ? this.dataSeriesV2 : <any>null;
        data["constV1"] = this.constV1 !== undefined ? this.constV1 : <any>null;
        data["constV2"] = this.constV2 !== undefined ? this.constV2 : <any>null;
        data["skipItemsV1"] = this.skipItemsV1 !== undefined ? this.skipItemsV1 : <any>null;
        data["skipItemsV2"] = this.skipItemsV2 !== undefined ? this.skipItemsV2 : <any>null;
        data["takeItemsV1"] = this.takeItemsV1 !== undefined ? this.takeItemsV1 : <any>null;
        data["takeItemsV2"] = this.takeItemsV2 !== undefined ? this.takeItemsV2 : <any>null;
        data["transformItemsV1"] = this.transformItemsV1 !== undefined ? this.transformItemsV1 : <any>null;
        data["transformItemsV2"] = this.transformItemsV2 !== undefined ? this.transformItemsV2 : <any>null;
        data["condition"] = this.condition !== undefined ? this.condition : <any>null;
        return data; 
    }
}

export interface IRule {
    ruleId: number;
    name?: string | null;
    description?: string | null;
    deleted: boolean;
    period: QuotePeriod;
    dataSourceV1: DataSourceType;
    dataSourceV2: DataSourceType;
    dataSeriesV1: number;
    dataSeriesV2: number;
    constV1?: string | null;
    constV2?: string | null;
    skipItemsV1: number;
    skipItemsV2: number;
    takeItemsV1: number;
    takeItemsV2: number;
    transformItemsV1: TransformFunction;
    transformItemsV2: TransformFunction;
    condition: CompareOperator;
}

export enum DataSourceType {
    Indicator = <any>"Indicator", 
    HistoricalData = <any>"HistoricalData", 
    Constant = <any>"Constant", 
}

export enum TransformFunction {
    First = <any>"First", 
    Max = <any>"Max", 
    Sum = <any>"Sum", 
    Avg = <any>"Avg", 
    Min = <any>"Min", 
}

export enum CompareOperator {
    Greater = <any>"Greater", 
    GreaterOrEqual = <any>"GreaterOrEqual", 
    Equal = <any>"Equal", 
    Less = <any>"Less", 
    LessOrEqual = <any>"LessOrEqual", 
    NotEqual = <any>"NotEqual", 
}

export class RuleSetModel implements IRuleSetModel {
    rules?: RuleModel[] | null;
    period: QuotePeriod;
    ruleSetId: number;
    name?: string | null;
    deleted: boolean;
    description?: string | null;

    constructor(data?: IRuleSetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(RuleModel.fromJS(item));
            }
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            this.ruleSetId = data["ruleSetId"] !== undefined ? data["ruleSetId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): RuleSetModel {
        let result = new RuleSetModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["period"] = this.period !== undefined ? this.period : <any>null;
        data["ruleSetId"] = this.ruleSetId !== undefined ? this.ruleSetId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IRuleSetModel {
    rules?: RuleModel[] | null;
    period: QuotePeriod;
    ruleSetId: number;
    name?: string | null;
    deleted: boolean;
    description?: string | null;
}

export class RuleModel implements IRuleModel {
    name?: string | null;
    ruleId: number;
    ruleSetId: number;
    orderId: number;
    description?: string | null;
    deleted: boolean;

    constructor(data?: IRuleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.ruleId = data["ruleId"] !== undefined ? data["ruleId"] : <any>null;
            this.ruleSetId = data["ruleSetId"] !== undefined ? data["ruleSetId"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
        }
    }

    static fromJS(data: any): RuleModel {
        let result = new RuleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["ruleId"] = this.ruleId !== undefined ? this.ruleId : <any>null;
        data["ruleSetId"] = this.ruleSetId !== undefined ? this.ruleSetId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        return data; 
    }
}

export interface IRuleModel {
    name?: string | null;
    ruleId: number;
    ruleSetId: number;
    orderId: number;
    description?: string | null;
    deleted: boolean;
}

export class VStrategyRuleSet implements IVStrategyRuleSet {
    strategyId: number;
    strategyActive: boolean;
    ruleSetId: number;
    ruleSetName?: string | null;
    ruleSetDescription?: string | null;
    ruleSetPeriod: number;
    ruleSetOrderId: number;
    ruleSetOptional: boolean;

    constructor(data?: IVStrategyRuleSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.strategyId = data["strategyId"] !== undefined ? data["strategyId"] : <any>null;
            this.strategyActive = data["strategyActive"] !== undefined ? data["strategyActive"] : <any>null;
            this.ruleSetId = data["ruleSetId"] !== undefined ? data["ruleSetId"] : <any>null;
            this.ruleSetName = data["ruleSetName"] !== undefined ? data["ruleSetName"] : <any>null;
            this.ruleSetDescription = data["ruleSetDescription"] !== undefined ? data["ruleSetDescription"] : <any>null;
            this.ruleSetPeriod = data["ruleSetPeriod"] !== undefined ? data["ruleSetPeriod"] : <any>null;
            this.ruleSetOrderId = data["ruleSetOrderId"] !== undefined ? data["ruleSetOrderId"] : <any>null;
            this.ruleSetOptional = data["ruleSetOptional"] !== undefined ? data["ruleSetOptional"] : <any>null;
        }
    }

    static fromJS(data: any): VStrategyRuleSet {
        let result = new VStrategyRuleSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strategyId"] = this.strategyId !== undefined ? this.strategyId : <any>null;
        data["strategyActive"] = this.strategyActive !== undefined ? this.strategyActive : <any>null;
        data["ruleSetId"] = this.ruleSetId !== undefined ? this.ruleSetId : <any>null;
        data["ruleSetName"] = this.ruleSetName !== undefined ? this.ruleSetName : <any>null;
        data["ruleSetDescription"] = this.ruleSetDescription !== undefined ? this.ruleSetDescription : <any>null;
        data["ruleSetPeriod"] = this.ruleSetPeriod !== undefined ? this.ruleSetPeriod : <any>null;
        data["ruleSetOrderId"] = this.ruleSetOrderId !== undefined ? this.ruleSetOrderId : <any>null;
        data["ruleSetOptional"] = this.ruleSetOptional !== undefined ? this.ruleSetOptional : <any>null;
        return data; 
    }
}

export interface IVStrategyRuleSet {
    strategyId: number;
    strategyActive: boolean;
    ruleSetId: number;
    ruleSetName?: string | null;
    ruleSetDescription?: string | null;
    ruleSetPeriod: number;
    ruleSetOrderId: number;
    ruleSetOptional: boolean;
}

export class GlobalIndexChartData implements IGlobalIndexChartData {
    periods?: ChartData[] | null;
    company?: CompanyInfo | null;

    constructor(data?: IGlobalIndexChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["periods"] && data["periods"].constructor === Array) {
                this.periods = [];
                for (let item of data["periods"])
                    this.periods.push(ChartData.fromJS(item));
            }
            this.company = data["company"] ? CompanyInfo.fromJS(data["company"]) : <any>null;
        }
    }

    static fromJS(data: any): GlobalIndexChartData {
        let result = new GlobalIndexChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.periods && this.periods.constructor === Array) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item.toJSON());
        }
        data["company"] = this.company ? this.company.toJSON() : <any>null;
        return data; 
    }
}

export interface IGlobalIndexChartData {
    periods?: ChartData[] | null;
    company?: CompanyInfo | null;
}

export class CompanyChartData extends GlobalIndexChartData implements ICompanyChartData {
    ruleSets?: StrategyRuleSetResult[] | null;

    constructor(data?: ICompanyChartData) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ruleSets"] && data["ruleSets"].constructor === Array) {
                this.ruleSets = [];
                for (let item of data["ruleSets"])
                    this.ruleSets.push(StrategyRuleSetResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyChartData {
        let result = new CompanyChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleSets && this.ruleSets.constructor === Array) {
            data["ruleSets"] = [];
            for (let item of this.ruleSets)
                data["ruleSets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICompanyChartData extends IGlobalIndexChartData {
    ruleSets?: StrategyRuleSetResult[] | null;
}

export class StrategyRuleSetResult implements IStrategyRuleSetResult {
    ruleSetId: number;
    name?: string | null;
    progress: number;
    rules?: StrategyRuleResult[] | null;

    constructor(data?: IStrategyRuleSetResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleSetId = data["ruleSetId"] !== undefined ? data["ruleSetId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.progress = data["progress"] !== undefined ? data["progress"] : <any>null;
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(StrategyRuleResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StrategyRuleSetResult {
        let result = new StrategyRuleSetResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleSetId"] = this.ruleSetId !== undefined ? this.ruleSetId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["progress"] = this.progress !== undefined ? this.progress : <any>null;
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStrategyRuleSetResult {
    ruleSetId: number;
    name?: string | null;
    progress: number;
    rules?: StrategyRuleResult[] | null;
}

export class StrategyRuleResult implements IStrategyRuleResult {
    condition: CompareOperator;
    ruleSetId: number;
    ruleId: number;
    ruleName?: string | null;
    ruleSetName?: string | null;
    firstValue: number;
    secondValue: number;
    valid: boolean;

    constructor(data?: IStrategyRuleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.condition = data["condition"] !== undefined ? data["condition"] : <any>null;
            this.ruleSetId = data["ruleSetId"] !== undefined ? data["ruleSetId"] : <any>null;
            this.ruleId = data["ruleId"] !== undefined ? data["ruleId"] : <any>null;
            this.ruleName = data["ruleName"] !== undefined ? data["ruleName"] : <any>null;
            this.ruleSetName = data["ruleSetName"] !== undefined ? data["ruleSetName"] : <any>null;
            this.firstValue = data["firstValue"] !== undefined ? data["firstValue"] : <any>null;
            this.secondValue = data["secondValue"] !== undefined ? data["secondValue"] : <any>null;
            this.valid = data["valid"] !== undefined ? data["valid"] : <any>null;
        }
    }

    static fromJS(data: any): StrategyRuleResult {
        let result = new StrategyRuleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condition"] = this.condition !== undefined ? this.condition : <any>null;
        data["ruleSetId"] = this.ruleSetId !== undefined ? this.ruleSetId : <any>null;
        data["ruleId"] = this.ruleId !== undefined ? this.ruleId : <any>null;
        data["ruleName"] = this.ruleName !== undefined ? this.ruleName : <any>null;
        data["ruleSetName"] = this.ruleSetName !== undefined ? this.ruleSetName : <any>null;
        data["firstValue"] = this.firstValue !== undefined ? this.firstValue : <any>null;
        data["secondValue"] = this.secondValue !== undefined ? this.secondValue : <any>null;
        data["valid"] = this.valid !== undefined ? this.valid : <any>null;
        return data; 
    }
}

export interface IStrategyRuleResult {
    condition: CompareOperator;
    ruleSetId: number;
    ruleId: number;
    ruleName?: string | null;
    ruleSetName?: string | null;
    firstValue: number;
    secondValue: number;
    valid: boolean;
}

export class ChartData implements IChartData {
    quotes?: QuotesModel[] | null;
    indicators?: IndicatorChartData[] | null;
    period: QuotePeriod;
    name?: string | null;

    constructor(data?: IChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["quotes"] && data["quotes"].constructor === Array) {
                this.quotes = [];
                for (let item of data["quotes"])
                    this.quotes.push(QuotesModel.fromJS(item));
            }
            if (data["indicators"] && data["indicators"].constructor === Array) {
                this.indicators = [];
                for (let item of data["indicators"])
                    this.indicators.push(IndicatorChartData.fromJS(item));
            }
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ChartData {
        let result = new ChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.quotes && this.quotes.constructor === Array) {
            data["quotes"] = [];
            for (let item of this.quotes)
                data["quotes"].push(item.toJSON());
        }
        if (this.indicators && this.indicators.constructor === Array) {
            data["indicators"] = [];
            for (let item of this.indicators)
                data["indicators"].push(item.toJSON());
        }
        data["period"] = this.period !== undefined ? this.period : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IChartData {
    quotes?: QuotesModel[] | null;
    indicators?: IndicatorChartData[] | null;
    period: QuotePeriod;
    name?: string | null;
}

export class IndicatorChartData implements IIndicatorChartData {
    indicator?: IIndicatorEntity | null;
    indicatorValues?: IndicatorResult[] | null;

    constructor(data?: IIndicatorChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.indicator = data["indicator"] ? IIndicatorEntity.fromJS(data["indicator"]) : <any>null;
            if (data["indicatorValues"] && data["indicatorValues"].constructor === Array) {
                this.indicatorValues = [];
                for (let item of data["indicatorValues"])
                    this.indicatorValues.push(IndicatorResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IndicatorChartData {
        let result = new IndicatorChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>null;
        if (this.indicatorValues && this.indicatorValues.constructor === Array) {
            data["indicatorValues"] = [];
            for (let item of this.indicatorValues)
                data["indicatorValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIndicatorChartData {
    indicator?: IIndicatorEntity | null;
    indicatorValues?: IndicatorResult[] | null;
}

export class IIndicatorEntity implements IIIndicatorEntity {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | null;
    name?: string | null;
    jsonParams?: string | null;
    description?: string | null;

    constructor(data?: IIIndicatorEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.indicatorId = data["indicatorId"] !== undefined ? data["indicatorId"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            if (data["params"] && data["params"].constructor === Array) {
                this.params = [];
                for (let item of data["params"])
                    this.params.push(IndicatorParam.fromJS(item));
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.jsonParams = data["jsonParams"] !== undefined ? data["jsonParams"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): IIndicatorEntity {
        let result = new IIndicatorEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indicatorId"] = this.indicatorId !== undefined ? this.indicatorId : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        if (this.params && this.params.constructor === Array) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["jsonParams"] = this.jsonParams !== undefined ? this.jsonParams : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IIIndicatorEntity {
    indicatorId: number;
    period: QuotePeriod;
    params?: IndicatorParam[] | null;
    name?: string | null;
    jsonParams?: string | null;
    description?: string | null;
}

export class IndicatorResult implements IIndicatorResult {
    date: Date;
    values?: IndicatorValueItem[] | null;

    constructor(data?: IIndicatorResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(IndicatorValueItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IndicatorResult {
        let result = new IndicatorResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIndicatorResult {
    date: Date;
    values?: IndicatorValueItem[] | null;
}

export class IndicatorValueItem implements IIndicatorValueItem {
    kind: ValueKind;
    name?: string | null;
    value: number;
    lineColor?: string | null;
    chartType: ChartType;

    constructor(data?: IIndicatorValueItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kind = data["kind"] !== undefined ? data["kind"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
            this.lineColor = data["lineColor"] !== undefined ? data["lineColor"] : <any>null;
            this.chartType = data["chartType"] !== undefined ? data["chartType"] : <any>null;
        }
    }

    static fromJS(data: any): IndicatorValueItem {
        let result = new IndicatorValueItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind !== undefined ? this.kind : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["lineColor"] = this.lineColor !== undefined ? this.lineColor : <any>null;
        data["chartType"] = this.chartType !== undefined ? this.chartType : <any>null;
        return data; 
    }
}

export interface IIndicatorValueItem {
    kind: ValueKind;
    name?: string | null;
    value: number;
    lineColor?: string | null;
    chartType: ChartType;
}

export enum ValueKind {
    Value = <any>"Value", 
    NewNigh = <any>"NewNigh", 
    NewLow = <any>"NewLow", 
    UpperBand = <any>"UpperBand", 
    LowerBand = <any>"LowerBand", 
}

export class CompanyInfo implements ICompanyInfo {
    ticker?: string | null;
    name?: string | null;

    constructor(data?: ICompanyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticker = data["ticker"] !== undefined ? data["ticker"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CompanyInfo {
        let result = new CompanyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticker"] = this.ticker !== undefined ? this.ticker : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICompanyInfo {
    ticker?: string | null;
    name?: string | null;
}

export class StrategySummary implements IStrategySummary {
    active: boolean;
    url?: string | null;
    summary?: string | null;
    strategyId: number;
    title?: string | null;

    constructor(data?: IStrategySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.summary = data["summary"] !== undefined ? data["summary"] : <any>null;
            this.strategyId = data["strategyId"] !== undefined ? data["strategyId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
        }
    }

    static fromJS(data: any): StrategySummary {
        let result = new StrategySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        data["strategyId"] = this.strategyId !== undefined ? this.strategyId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        return data; 
    }
}

export interface IStrategySummary {
    active: boolean;
    url?: string | null;
    summary?: string | null;
    strategyId: number;
    title?: string | null;
}

export class StrategyModel implements IStrategyModel {
    ruleSets?: StrategyRuleSetModel[] | null;
    blocks?: any[] | null;
    strategyId: number;
    title?: string | null;
    deleted: boolean;
    summary?: string | null;
    active: boolean;
    url?: string | null;

    constructor(data?: IStrategyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ruleSets"] && data["ruleSets"].constructor === Array) {
                this.ruleSets = [];
                for (let item of data["ruleSets"])
                    this.ruleSets.push(StrategyRuleSetModel.fromJS(item));
            }
            if (data["blocks"] && data["blocks"].constructor === Array) {
                this.blocks = [];
                for (let item of data["blocks"])
                    this.blocks.push(item);
            }
            this.strategyId = data["strategyId"] !== undefined ? data["strategyId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.summary = data["summary"] !== undefined ? data["summary"] : <any>null;
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
        }
    }

    static fromJS(data: any): StrategyModel {
        let result = new StrategyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleSets && this.ruleSets.constructor === Array) {
            data["ruleSets"] = [];
            for (let item of this.ruleSets)
                data["ruleSets"].push(item.toJSON());
        }
        if (this.blocks && this.blocks.constructor === Array) {
            data["blocks"] = [];
            for (let item of this.blocks)
                data["blocks"].push(item);
        }
        data["strategyId"] = this.strategyId !== undefined ? this.strategyId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        return data; 
    }
}

export interface IStrategyModel {
    ruleSets?: StrategyRuleSetModel[] | null;
    blocks?: any[] | null;
    strategyId: number;
    title?: string | null;
    deleted: boolean;
    summary?: string | null;
    active: boolean;
    url?: string | null;
}

export class StrategyRuleSetModel implements IStrategyRuleSetModel {
    rules?: StrategyRuleModel[] | null;
    description?: string | null;
    name?: string | null;
    optional: boolean;
    orderId: number;
    period: number;
    ruleSetId: number;

    constructor(data?: IStrategyRuleSetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(StrategyRuleModel.fromJS(item));
            }
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.optional = data["optional"] !== undefined ? data["optional"] : <any>null;
            this.orderId = data["orderId"] !== undefined ? data["orderId"] : <any>null;
            this.period = data["period"] !== undefined ? data["period"] : <any>null;
            this.ruleSetId = data["ruleSetId"] !== undefined ? data["ruleSetId"] : <any>null;
        }
    }

    static fromJS(data: any): StrategyRuleSetModel {
        let result = new StrategyRuleSetModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["optional"] = this.optional !== undefined ? this.optional : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        data["ruleSetId"] = this.ruleSetId !== undefined ? this.ruleSetId : <any>null;
        return data; 
    }
}

export interface IStrategyRuleSetModel {
    rules?: StrategyRuleModel[] | null;
    description?: string | null;
    name?: string | null;
    optional: boolean;
    orderId: number;
    period: number;
    ruleSetId: number;
}

export class StrategyRuleModel implements IStrategyRuleModel {

    constructor(data?: IStrategyRuleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): StrategyRuleModel {
        let result = new StrategyRuleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IStrategyRuleModel {
}

export class Strategy implements IStrategy {
    strategyId: number;
    name?: string | null;
    url?: string | null;
    jsonArticleBlocks?: string | null;
    description?: string | null;
    deleted: boolean;
    active: boolean;

    constructor(data?: IStrategy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.strategyId = data["strategyId"] !== undefined ? data["strategyId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.jsonArticleBlocks = data["jsonArticleBlocks"] !== undefined ? data["jsonArticleBlocks"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
        }
    }

    static fromJS(data: any): Strategy {
        let result = new Strategy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["strategyId"] = this.strategyId !== undefined ? this.strategyId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["jsonArticleBlocks"] = this.jsonArticleBlocks !== undefined ? this.jsonArticleBlocks : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data; 
    }
}

export interface IStrategy {
    strategyId: number;
    name?: string | null;
    url?: string | null;
    jsonArticleBlocks?: string | null;
    description?: string | null;
    deleted: boolean;
    active: boolean;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, null);
}